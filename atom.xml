<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangjiao&#39;s blog</title>
  
  
  <link href="https://yyangjiao.github.io/atom.xml" rel="self"/>
  
  <link href="https://yyangjiao.github.io/"/>
  <updated>2021-10-21T08:59:42.803Z</updated>
  <id>https://yyangjiao.github.io/</id>
  
  <author>
    <name>yangjiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cpp-note</title>
    <link href="https://yyangjiao.github.io/2021/10/21/cpp-note/"/>
    <id>https://yyangjiao.github.io/2021/10/21/cpp-note/</id>
    <published>2021-10-21T08:50:24.000Z</published>
    <updated>2021-10-21T08:59:42.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="1-指针数据类型所占的内存空间"><a href="#1-指针数据类型所占的内存空间" class="headerlink" title="1.指针数据类型所占的内存空间"></a>1.指针数据类型所占的内存空间</h3><p>32位操作系统下，所有指针数据类型所占的内存空间都是4个字节；</p><p>64位操作系统下，所有指针数据类型所占的内存空间都是8个字节；</p><h3 id="2-空指针"><a href="#2-空指针" class="headerlink" title="2.空指针"></a>2.空指针</h3><p>空指针：指针变量指向内存中编号为0的空间</p><p>用途：初始化指针变量</p><p>注意点：空指针指向的内存是不可以访问的（内存编号0~255的空间为系统占用内存，不允许用户访问）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">*p = <span class="number">100</span>;<span class="comment">//报错</span></span><br><span class="line">cout &lt;&lt; *p;<span class="comment">//报错</span></span><br><span class="line">cout &lt;&lt; p;<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure><h3 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3.野指针"></a>3.野指针</h3><p>野指针：指针变量指向非法的内存空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="number">0x1100</span>;<span class="comment">//p就是一个野指针</span></span><br><span class="line">cout &lt;&lt; *p;<span class="comment">//异常：读取访问权限冲突</span></span><br></pre></td></tr></table></figure><p>总结：空指针和野指针指向的内存空间不是我们自己申请的，要避免使用它们</p><h3 id="4-const修饰指针"><a href="#4-const修饰指针" class="headerlink" title="4.const修饰指针"></a>4.const修饰指针</h3><p><strong>转载自：</strong><a href="https://blog.csdn.net/CFrieman/article/details/79148232?utm_source=blogxgwz8">https://blog.csdn.net/CFrieman/article/details/79148232?utm_source=blogxgwz8</a></p><ul><li><p>const int *p 指向常量的指针 </p><p>就是所谓的“指向常量的指针”。这里注意，所谓“指向常量”只是这个指针的“一厢情愿”，只是一种效果上的等价。事实上，const int *p=&a;a既可以是常量(const int a=10;)又可以是变量(int a=10;)，但p一厢情愿地认为它所指的就是一个常量，所以它不允许通过自己来修改所指，这就造成一种效果上的等价——从p的角度看，它所指的“的确”是常量。所以，对“指向常量的指针”的最佳理解应为：我们不能通过该指针修改它所指向的东西（常量或者变量）。</p><p>注意，const int *p=&a;只是说不能通过p来修改a，如果a本身不是const的，通过其它方式修改a自然是可以的（例如直接++a）。</p><p>另外一点，由于p本身只是一个普通的指针，所以允许在声明时不初始化。但需要注意的是，我们只是说可以，但并不提倡这样做。在任何时候都不应该让指针无所指，如果在声明一个指针时还不知道让它指向谁，就先将其初始化为nullptr或NULL（nullptr是C++11新特性，用它比用NULL更安全些，这里不详细介绍）。</p><p>注意：int const* p = &a; 这种写法也是对的</p></li><li><p>int* const p 指针常量</p><p>就是所谓的“本身是常量的指针”。p本身（也就是p的指向）不能修改但可以通过p修改其所指向的变量值，所以p只能指向变量，不可以指向常量。这里再说一下p的初始化：</p><p>由于p本身是const的，所以在编译的时候必须知道p的值（即p所指向的东西的地址），所以在声明p的同时必须初始化p。但要注意，对于 int* const p=&amp;a，我们只要求a的地址是确定的，但a的值可以不确定，就是说a可以声明但不初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;<span class="comment">//声明但未初始化a</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;<span class="comment">//错误：声明p的同时没有初始化p</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外注意，用nullptr或NULL初始化int* const p没有问题，因为nullptr和NULL都代表有效地址。</p></li><li><p>const int* const p</p><p>就是所谓的“所指和本身都是常量的指针”。它的语法特性就是前两者的结合，这里不再赘述。</p></li></ul><h3 id="5-指针和数组"><a href="#5-指针和数组" class="headerlink" title="5.指针和数组"></a>5.指针和数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">double</span>* p = arr;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;<span class="comment">//p此时指向arr[0] 故打印出arr[0]的地址</span></span><br><span class="line">p++;<span class="comment">//我理解的是：让p指向arr[0]的同时p+1指向了arr[1]，p = p+1后，p就指向了arr[1],所以打印的地址值相差sizeof(double)</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;<span class="comment">//p此时指向arr[1] 故打印出arr[1]的地址</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************结果**************************</span></span><br><span class="line"><span class="number">008F</span>F874</span><br><span class="line"><span class="number">008F</span>F87C</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="6-指针和函数"><a href="#6-指针和函数" class="headerlink" title="6.指针和函数"></a>6.指针和函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *num1;</span><br><span class="line">*num1 = *num2;</span><br><span class="line">*num2 = temp;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************结果**************************</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="1-结构体定义和使用"><a href="#1-结构体定义和使用" class="headerlink" title="1.结构体定义和使用"></a>1.结构体定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;ps3;<span class="comment">//结构体使用3(定义结构体的同时创建结构体变量，不建议使用)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//结构体使用1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">ps1</span>;</span></span><br><span class="line">ps1.name = <span class="string">&quot;LiHua&quot;</span>;</span><br><span class="line">ps1.age = <span class="number">19</span>;</span><br><span class="line"><span class="comment">//结构体使用2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">ps2</span> =</span> &#123; <span class="string">&quot;YangJiao&quot;</span>,<span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="comment">//struct Person ps2&#123; &quot;YangJiao&quot;,20 &#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：创建结构体变量时，struct关键字可以省略</p><h3 id="2-结构体数组"><a href="#2-结构体数组" class="headerlink" title="2.结构体数组"></a>2.结构体数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//结构体数组</span></span><br><span class="line">Person psArr[<span class="number">3</span>] = &#123; &#123;<span class="string">&quot;LiHua&quot;</span>,<span class="number">19</span>&#125;,&#123;<span class="string">&quot;YangJiao&quot;</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&quot;PeiYun&quot;</span>,<span class="number">21</span>&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-结构体指针"><a href="#3-结构体指针" class="headerlink" title="3.结构体指针"></a>3.结构体指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person ps = &#123; <span class="string">&quot;LiHua&quot;</span>,<span class="number">19</span> &#125;;</span><br><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line">Person* psPtr = &amp;ps;</span><br><span class="line">cout &lt;&lt; psPtr-&gt;name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; psPtr-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************结果**************************</span></span><br><span class="line">LiHua</span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure><h3 id="4-结构体嵌套结构体"><a href="#4-结构体嵌套结构体" class="headerlink" title="4.结构体嵌套结构体"></a>4.结构体嵌套结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;<span class="comment">//结构体定义struct Student &#123;string name;int age;&#125;;struct Teacher &#123;string name;int age;string subject;Student stu;&#125;;int main() &#123;Teacher tc = &#123; &quot;WangMing&quot;,37,&quot;Math&quot;,&#123;&quot;LiHua&quot;,20&#125; &#125;;//或//Teacher tc&#123; &quot;WangMing&quot;,37,&quot;Math&quot;,&#123;&quot;LiHua&quot;,20&#125; &#125;;cout &lt;&lt; tc.stu.name;&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="5-结构体作函数参数"><a href="#5-结构体作函数参数" class="headerlink" title="5.结构体作函数参数"></a>5.结构体作函数参数</h3><p>作用：结构体作为参数向函数中传递</p><p>传递方式：值传递和地址传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*********************值传递*********************#include&lt;iostream&gt;using namespace std;//结构体定义struct Person &#123;string name;int age;&#125;;void printPerson(Person _ps) &#123;_ps.age = 21;cout &lt;&lt; &quot;name_printPerson: &quot; &lt;&lt; _ps.name &lt;&lt; endl;cout &lt;&lt; &quot;age_printPerson: &quot; &lt;&lt; _ps.age &lt;&lt; endl;&#125;int main() &#123;Person ps = &#123; &quot;LiHua&quot;,20 &#125;;printPerson(ps);cout &lt;&lt;&quot;age_main: &quot;&lt;&lt; ps.age;&#125;//*********************结果*********************name_printPerson: LiHuaage_printPerson: 21age_main: 20</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//********************地址传递********************#include&lt;iostream&gt;using namespace std;//结构体定义struct Person &#123;string name;int age;&#125;;void printPerson(Person* _ps) &#123;_ps-&gt;age = 21;cout &lt;&lt; &quot;name_printPerson: &quot; &lt;&lt; _ps-&gt;name &lt;&lt; endl;cout &lt;&lt; &quot;age_printPerson: &quot; &lt;&lt; _ps-&gt;age &lt;&lt; endl;&#125;int main() &#123;Person ps = &#123; &quot;LiHua&quot;,20 &#125;;printPerson(&amp;ps);cout &lt;&lt;&quot;age_main: &quot;&lt;&lt; ps.age;&#125;//*********************结果*********************name_printPerson: LiHuaage_printPerson: 21age_main: 21</span></span><br></pre></td></tr></table></figure><h3 id="6-结构体中const的使用场景"><a href="#6-结构体中const的使用场景" class="headerlink" title="6.结构体中const的使用场景"></a>6.结构体中const的使用场景</h3><p>作用：用const来防止误操作</p><p>当我们的函数只要求读取，而不修改传入的参数时，可以使用值传递，但是会复制新的副本，占用内存空间，地址传递可以减少内存空间的浪费，但是可能由于误操作在函数内部将参数修改掉，为了避免这种误操作，我们就需要使用const</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;<span class="comment">//结构体定义struct Person &#123;string name;int age;&#125;;void printPerson(const Person* _ps) &#123;//这是一个常量指针    //这个函数的目的功能就是只读取，而不修改传入的参数cout &lt;&lt; &quot;name: &quot; &lt;&lt; _ps-&gt;name &lt;&lt; endl;cout &lt;&lt; &quot;age: &quot; &lt;&lt; _ps-&gt;age &lt;&lt; endl;_ps-&gt;age = -1;//假如不小心加入这一误操作，编译器就会报错&#125;int main() &#123;Person ps = &#123; &quot;LiHua&quot;,20 &#125;;&#125;</span></span></span><br></pre></td></tr></table></figure><h1 id="C-核心"><a href="#C-核心" class="headerlink" title="C++核心"></a>C++核心</h1><h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序在执行时，将内存大方向上划分为4个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量、静态变量和部分常量</li><li>栈区：由编译器自动分配释放，存放函数的形参和局部变量</li><li>堆区：由程序员分配和释放，若程序员没有进行释放操作，程序结束时由操作系统回收</li></ul><p>内存分区的意义：不同区域存放不同类型的数据，赋予不同的生命周期，方便更加灵活的进行编程</p><h3 id="1-代码区和全局区"><a href="#1-代码区和全局区" class="headerlink" title="1.代码区和全局区"></a>1.代码区和全局区</h3><p>程序运行前:</p><p>在程序编译后，生成了exe可执行文件，在还未执行该exe文件前，内存中就分好了两个区域</p><ul><li><p>代码区：</p><ul><li>存放CPU执行的机器指令</li><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可（简单来说就是我们连续多次执行该exe文件，执行的都是这一份代码）</li><li>代码区是<strong>只读</strong>的，目的是防止意外地修改了程序的指令</li></ul></li><li><p>全局区：</p><ul><li><p>存放全局变量和静态变量</p></li><li><p>全局区中包含常量区，故字符串常量和全局常量也存放在这里（局部常量不在常量区，而与局部变量在一个区域）</p></li><li><p>该区域的数据在程序结束后由操作系统释放</p></li><li><p>```c++<br>#include<iostream>using namespace std;//全局变量int g_a = 0;int g_b = 0;//全局常量const int G_A = 0;const int G_B = 0;int main() {    //局部变量    int a = 0;    int b = 0;    //静态变量    static int s_a = 0;    static int s_b = 0;    //局部常量    const int A = 0;    const int B = 0;    cout &lt;&lt; “局部变量a的地址：” &lt;&lt; (int)&amp;a &lt;&lt; endl;    cout &lt;&lt; “局部变量b的地址：” &lt;&lt; (int)&amp;b &lt;&lt; endl;    cout &lt;&lt; “全局变量g_a的地址：” &lt;&lt; (int)&amp;g_a &lt;&lt; endl;    cout &lt;&lt; “全局变量g_b的地址：” &lt;&lt; (int)&amp;g_b &lt;&lt; endl;    cout &lt;&lt; “静态变量s_a的地址：” &lt;&lt; (int)&amp;s_a &lt;&lt; endl;    cout &lt;&lt; “静态变量s_b的地址：” &lt;&lt; (int)&amp;s_b &lt;&lt; endl;    cout &lt;&lt; “字符串常量&quot;hello world&quot;的地址” &lt;&lt; (int)&amp;”hello world” &lt;&lt; endl;    cout &lt;&lt; “全局常量G_A的地址：” &lt;&lt; (int)&amp;G_A &lt;&lt; endl;    cout &lt;&lt; “全局常量G_B的地址：” &lt;&lt; (int)&amp;G_B &lt;&lt; endl;    cout &lt;&lt; “局部常量A的地址” &lt;&lt; (int)&amp;A &lt;&lt; endl;    cout &lt;&lt; “局部常量B的地址” &lt;&lt; (int)&amp;B &lt;&lt; endl;}//<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>结果</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>局部变量a的地址：7339264局部变量b的地址：7339252全局变量g_a的地址：8504428全局变量g_b的地址：8504432静态变量s_a的地址：8504436静态变量s_b的地址：8504440字符串常量”hello world”的地址8494096全局常量G_A的地址：8494376全局常量G_B的地址：8494380局部常量A的地址7339240局部常量B的地址7339228</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.栈区和堆区</span><br><span class="line"></span><br><span class="line">程序运行后：</span><br><span class="line"></span><br><span class="line">- 栈区：</span><br><span class="line"></span><br><span class="line">  - 由编译器自动分配和释放内存，存放的是函数的形参和局部变量（还有局部常量）</span><br><span class="line"></span><br><span class="line">  - **注意事项：**不要返回局部变量的地址</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    #include&lt;iostream&gt;using namespace std;int* func() &#123;int a = 10;//编译器自动为局部变量a分配了一块内存空间来存放数据10，当fun()函数执行完后，这块内存空间又会被自动释放，这块空间中存放的数据就不在是10了cout &lt;&lt; &quot;为a分配的内存空间地址: &quot; &lt;&lt; &amp;a &lt;&lt; endl;return &amp;a;&#125;int main() &#123;int* p = func();//p指向func()中为a分配的内存空间cout &lt;&lt; p &lt;&lt; endl;cout &lt;&lt; *p &lt;&lt; endl;&#125;//*********************结果*********************为a分配的内存空间地址: 0073FBE40073FBE4//p是指向这块空间2067712528//但是这块空间中存放的值不再是10了</span><br></pre></td></tr></table></figure></li></ul></li><li><p>堆区：</p><ul><li><p>由程序员分配释放，若程序员没有进行释放操作，程序结束时由操作系统回收</p></li><li><p>在C++中主要利用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;int* func() &#123;<span class="comment">//使用new关键字在堆区为数据分配空间int* p = new int(10);//new返回的是地址，所以用一个指针接收return p;&#125;int main() &#123;//在堆区为数据分配空间int* ptr = func();cout &lt;&lt; *ptr &lt;&lt; endl;&#125;</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-new操作符"><a href="#3-new操作符" class="headerlink" title="3.new操作符"></a>3.new操作符</h3><ul><li><p>C++中利用new操作符在堆区为数据开辟空间</p></li><li><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放要使用delete操作符</p></li><li><p>使用new在堆区为数据开辟空间，返回的是一个地址，需要用该数据对应类型的指针接收</p></li><li><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;int main() &#123;<span class="comment">//基本数据类型int* p = new int(10); //数据值为10cout &lt;&lt; *p &lt;&lt; endl;delete p;//数组int* pArr = new int[10]; //数组有10个元素delete[] pArr;&#125;</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="1-引用的基本使用"><a href="#1-引用的基本使用" class="headerlink" title="1.引用的基本使用"></a>1.引用的基本使用</h3><ul><li><p>作用：给变量起个别名</p></li><li><p>语法：数据类型 &amp;别名 =  原名;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;int main() &#123;int LiHua = 10;int&amp; YangJiao = LiHua;cout &lt;&lt; LiHua &lt;&lt; endl;cout &lt;&lt; YangJiao &lt;&lt; endl;YangJiao = 20;cout &lt;&lt; LiHua &lt;&lt; endl;cout &lt;&lt; YangJiao &lt;&lt; endl;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-引用注意事项"><a href="#2-引用注意事项" class="headerlink" title="2.引用注意事项"></a>2.引用注意事项</h3><ul><li><p>引用必须初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;YangJiao;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li><li><p>引用在初始化之后，不可以改变</p></li></ul><h3 id="3-引用作函数参数"><a href="#3-引用作函数参数" class="headerlink" title="3.引用作函数参数"></a>3.引用作函数参数</h3><ul><li><p>作用：函数传参时，可以利用引用的技术，使得形参修饰实参（就是可以通过在函数中修改形参来修改实参）</p></li><li><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;void swap(int&amp; num1, int&amp; num2) &#123;int temp = num1;num1 = num2;num2 = temp;&#125;int main() &#123;int a = 10;int b = 20;swap(a, b);cout &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; b &lt;&lt; endl;&#125;<span class="comment">//*********************结果*********************2010</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-引用作函数返回值"><a href="#4-引用作函数返回值" class="headerlink" title="4.引用作函数返回值"></a>4.引用作函数返回值</h3><ul><li><p>注意：不要返回局部变量的引用</p></li><li><p>用法：可将返回值为引用的函数作为左值使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;int&amp; func() &#123;static int a = 10;<span class="comment">//全局区的静态变量return a; &#125;int main() &#123;int&amp; ref = func();//func()返回的是a的引用cout &lt;&lt; ref &lt;&lt; endl;func() = 20;//函数作左值cout &lt;&lt; ref &lt;&lt; endl;&#125;//*********************结果*********************1020</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-引用的本质"><a href="#5-引用的本质" class="headerlink" title="5.引用的本质"></a>5.引用的本质</h3><ul><li><p>本质：引用的在C++内部的实现是一个指针常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;int main() &#123;int a = 10;int&amp; ref = a;<span class="comment">//自动转换为int* const ref = &amp;a; 指针常量不可以修改指向，这就说明为什么引用不可以更改 同样因为指针常量必须初始化，这点就说明了为什么引用必须初始化ref = 20; //编译器发现ref是引用，自动转换为*ref = 20;cout &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; ref &lt;&lt; endl;&#125;</span></span></span><br></pre></td></tr></table></figure></li><li><p>C++推荐使用引用技术，本质上是指针常量，但是语法上更加简单方便</p></li></ul><h3 id="6-常量引用"><a href="#6-常量引用" class="headerlink" title="6.常量引用"></a>6.常量引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;int main() &#123;int a = 10;<span class="comment">//int&amp; ref = 10;//错误：非常量引用的初始值必须为左值const int&amp; ref = 10;//常量引用//正确：const修饰后，编译器自动将代码转换为int temp = 10; int&amp; ref = temp;//ref = 20;//常量引用不可以修改&#125;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>作用：常量引用主要用来修饰形参，防止误操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;void print(const int&amp; ref) &#123;<span class="comment">//ref = 10;//若存在这样一条误操作，编译器会报错cout &lt;&lt; ref &lt;&lt; endl;&#125;int main() &#123;int a = 10;print(a);&#125;</span></span></span><br></pre></td></tr></table></figure></li><li><p>引用本质上是指针常量，所以常量引用本质上是指向常量的指针常量，不允许修改指向，但“指向常量”是它“一厢情愿”的，它自己认为自己指向的是常量，所以“不敢”修改指向对象的值，但实际上它指向的也可能是变量，虽然不能通过这个引用修改其值，但是可以通过直接修改这个变量来修改其值。（跳转至C++基础-指针-4.const修饰的指针）</p></li></ul><h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="1-函数默认值"><a href="#1-函数默认值" class="headerlink" title="1.函数默认值"></a>1.函数默认值</h3><ul><li>在C++中，函数形参列表中的形参是可以有默认值的</li><li>带默认值的参数只能在形参列表最右侧</li><li>函数声明和函数实现中只能有一个带默认值</li></ul><h3 id="2-函数占位参数"><a href="#2-函数占位参数" class="headerlink" title="2.函数占位参数"></a>2.函数占位参数</h3><ul><li><p>C++中函数的形参列表里可以有占位参数，用来作占位，调用函数时必须填补该位置</p></li><li><p>占位参数也可以有默认值</p></li><li><p>```c++<br>#include<iostream>using namespace std;void fun(int num1, int, int num2, int = 10) {//第2个和第4个参数都是占位参数，而且第4个参数有默认值    cout &lt;&lt; “函数的占位参数” &lt;&lt; endl;}int main() {    fun(1, 2, 3);}//<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>结果</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>函数的占位参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.函数重载</span><br><span class="line"></span><br><span class="line">- 作用：函数名可以相同，提高复用性</span><br><span class="line"></span><br><span class="line">- 函数重载的条件：</span><br><span class="line"></span><br><span class="line">  - 同一作用域下（目前我们的函数都是全局函数，满足这一条件）</span><br><span class="line">  - 函数名称相同</span><br><span class="line">  - 函数的形参类型或个数不同</span><br><span class="line">  - 注意：返回值不可以做为重载条件</span><br><span class="line"></span><br><span class="line">- 注意事项：</span><br><span class="line"></span><br><span class="line">  - 引用作重载条件</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    #include&lt;iostream&gt;using namespace std;void func(int&amp; ref) &#123;cout &lt;&lt; &quot;调用的是func(int&amp; ref)&quot; &lt;&lt; endl;&#125;void func(const int&amp; ref) &#123;cout &lt;&lt; &quot;调用的是func(const int&amp; ref)&quot; &lt;&lt; endl;&#125;int main() &#123;int a = 10;const int b = 10;func(a);func(10);func(b);&#125;//*********************结果*********************调用的是func(int&amp; ref)调用的是func(const int&amp; ref)调用的是func(const int&amp; ref)</span><br></pre></td></tr></table></figure><ul><li><p>当函数重载遇到默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;void func(int a, int b = 10) &#123;cout &lt;&lt; <span class="meta-string">&quot;func(int a, int b)&quot;</span> &lt;&lt; endl;&#125;void func(int a) &#123;cout &lt;&lt; <span class="meta-string">&quot;func(int a, int b)&quot;</span> &lt;&lt; endl;&#125;int main() &#123;int a = 10;func(10);<span class="comment">//报错:有多个重载函数与参数列表匹配&#125;</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特性：封装、继承、多态</p><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><ul><li>封装的意义：<ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>对属性和行为加以访问权限（public公共权限、protected保护权限、private私有权限）</li></ul></li><li>struct和class的区别：<ul><li>struct默认访问权限是public</li><li>class默认访问权限是private</li><li>注意：C++中没有default访问权限</li></ul></li><li>成员属性私有化<ul><li>优点：<ul><li>将所有成员属性私有化，可以由我们自己控制其读写权限（设置相应的权限为public的set和get函数，通过这些函数来读写成员属性）</li><li>对于写权限，我们可以通过对应的set函数，在函数内检验数据的有效性</li></ul></li></ul></li></ul><h3 id="2-对象的初始化和清理"><a href="#2-对象的初始化和清理" class="headerlink" title="2.对象的初始化和清理"></a>2.对象的初始化和清理</h3><ul><li><p>对象的初始化和清理是两个非常重要的安全问题：</p><ul><li>一个对象或者变量没有初始状态，对其使用的后果是未知的</li><li>使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</li></ul></li><li><p>构造函数和析构函数：</p><p>C++利用构造函数和析构函数解决上述的问题，这两个函数会被编译器自动调用来完成对象的初始化和清理，对象的初始化和清理是编译器要求我们做的事情，如果我们不提供任何构造函数和析构函数，编译器会提供默认的构造函数和析构函数（默认提供的构造函数和析构函数都是空实现，即函数体为空）</p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用</li><li>析构函数：主要作用在于在对象销毁前由编译器自动调用，执行一些清理工作</li></ul></li></ul><h4 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h4><ul><li><p>构造函数的分类</p><ul><li>按参数分为：有参构造函数和无参构造函数</li><li>按类型分为：普通构造函数和拷贝构造函数</li></ul></li><li><p>创建对象的3种方式：括号法、显示法、隐式转换法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;private:string name;int age;public:Person() &#123;cout &lt;&lt; <span class="meta-string">&quot;调用Person类的无参构造函数&quot;</span> &lt;&lt; endl;&#125;Person(string _name, int _age) &#123;name = _name;age = _age;cout &lt;&lt; <span class="meta-string">&quot;调用Person类的有参构造函数&quot;</span> &lt;&lt; endl;&#125;Person(const Person&amp; p) &#123;name = p.name;age = p.age;cout &lt;&lt; <span class="meta-string">&quot;调用Person类的拷贝构造函数&quot;</span> &lt;&lt; endl;&#125;~Person() &#123;cout &lt;&lt; <span class="meta-string">&quot;调用Person类的析构函数&quot;</span> &lt;&lt; endl;&#125;void setName(string _name) &#123;name = _name;&#125;string getName() &#123;return name;&#125;void setAge(int _age) &#123;age = _age;&#125;int getAge() &#123;return age;&#125;&#125;;void func() &#123;<span class="comment">//******************************1.括号法******************************Person p0;//调用无参构造函数创建对象Person p1(&quot;LiHua&quot;,19);//调用有参构造函数创建对象Person p2(p1);//调用拷贝构造函数创建对象//注意点：//括号法调用无参构造函数创建对象时，不要加括号Person p3(); //编译器会把该语句认为是函数的声明//******************************2.显示法（联想Java）********************Person p4 = Person();//调用无参构造函数创建对象Person p5 = Person(&quot;YangJiao&quot;, 20);//调用有参构造函数创建对象Person p6 = Person(p5);//调用拷贝构造函数创建对象Person(&quot;WangJie&quot;, 21);//调用有参构造函数创建的匿名对象//匿名对象注意点1：执行完当前行后，匿名对象就会被系统回收//匿名对象注意点2：不要利用拷贝构造函数创建匿名对象//Person(p6); //报错：原因是编译器认为Person(p6) === Person p6;造成重定义//******************************3.隐式转换法****************************    Person p7 = &#123; &quot;WangMing&quot;,20 &#125;;//当类只有一个成员变量时可以不加大括号     //等同于 Person p7(&quot;WangMing&quot;,20);    Person p9 = p8;//等同于Person p9(p8);&#125;int main() &#123;func();&#125;//***********************************结果***********************************调用Person类的无参构造函数调用Person类的有参构造函数调用Person类的拷贝构造函数调用Person类的无参构造函数调用Person类的有参构造函数调用Person类的拷贝构造函数调用Person类的有参构造函数调用Person类的析构函数调用Person类的有参构造函数调用Person类的拷贝构造函数调用Person类的析构函数调用Person类的析构函数调用Person类的析构函数调用Person类的析构函数调用Person类的析构函数调用Person类的析构函数调用Person类的析构函数调用Person类的析构函数</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2拷贝构造函数的调用时机"><a href="#2-2拷贝构造函数的调用时机" class="headerlink" title="2.2拷贝构造函数的调用时机"></a>2.2拷贝构造函数的调用时机</h4><p>C++种拷贝构造函数的调用时机通常有3种：</p><ul><li><p>使用一个已经存在的对象来创建并初始化一个新的对象时</p></li><li><p>函数发生值传递时会调用拷贝构造函数（因为值传递的本质是复制一份副本）</p></li><li><p>以值方式返回局部对象时（本质上也是复制了一份副本）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上一份代码基础上Person func1() &#123;Person p;cout &lt;&lt; (int)&amp;p &lt;&lt; endl;return p; &#125;int main() &#123;Person ps = func1();cout &lt;&lt; (int)&amp;ps &lt;&lt; endl;&#125;//结果调用Person类的无参构造函数//Person p;9436392//p的地址调用Person类的拷贝构造函数//return p调用Person类的析构函数//清理p9436668//ps的地址调用Person类的析构函数//清理ps//我的疑问：语句Person ps = func1(); 为什么不发生拷贝构造？/*已解决：func1()中完成的工作是：首先创建p对象，然后打印了这个对象的地址;然后通过拷贝构造函数把p拷贝到保存返回值的外部存储部件ps中；    最后，p对象在func1()函数结束时被销毁（调用p的析构函数）*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3构造函数调用规则"><a href="#2-3构造函数调用规则" class="headerlink" title="2.3构造函数调用规则"></a>2.3构造函数调用规则</h4><p>当我们没有编写任何构造函数和析构函数时，C++编译器至少给类添加3个函数</p><ul><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数（对属性值进行拷贝）</li></ul><p>默认构造函数的提供规则：</p><ul><li>如果用户定义了有参构造函数，C++不会再提供默认构造函数，但是仍会提供默认拷贝构造函数</li><li>如果用户定义了拷贝构造函数，C++不会再提供任何默认的构造函数</li></ul><h4 id="2-4深拷贝与浅拷贝"><a href="#2-4深拷贝与浅拷贝" class="headerlink" title="2.4深拷贝与浅拷贝"></a>2.4深拷贝与浅拷贝</h4><ul><li><p>浅拷贝：简单的赋值拷贝操作</p></li><li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p></li><li><p>浅拷贝带来的问题：可能导致堆区内存的重复释放，此外还有改一二变的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:string name;int *age;Person() &#123;cout &lt;&lt; <span class="meta-string">&quot;调用Person类的无参构造函数&quot;</span> &lt;&lt; endl;&#125;Person(string _name, int _age) &#123;cout &lt;&lt; <span class="meta-string">&quot;调用Person类的有参构造函数&quot;</span> &lt;&lt; endl;name = _name;age = new int(_age);&#125;Person(const Person&amp; p) &#123;<span class="comment">//默认拷贝构造函数就是这种浅拷贝形式cout &lt;&lt; &quot;调用Person类的拷贝构造函数&quot; &lt;&lt; endl;name = p.name;age = p.age;&#125;~Person() &#123;cout &lt;&lt; &quot;调用Person类的析构函数&quot; &lt;&lt; endl;if (age != NULL) &#123;delete age;age = NULL;&#125;&#125;&#125;;void func() &#123;Person p0(&quot;LiHua&quot;, 19);Person p1(p0);*p1.age = 10;cout &lt;&lt; *p0.age &lt;&lt; endl;//输出10cout &lt;&lt; *p1.age &lt;&lt; endl;//同样也是输出10 这就是改一二变问题&#125;int main() &#123;func();&#125;//解释：代码报错，因为p0.age和p1.age指向同一块堆区内存空间，func()函数执行结束后，依次调用了p1和p0的析构函数，对这块堆区内存空间重复释放（不允许重复释放同一块内存空间）；这里还涉及一个知识点，栈区的特点是是先进后出，我们先创建p0则后销毁p0</span></span></span><br></pre></td></tr></table></figure></li><li><p>深拷贝的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;<span class="comment">//这是我们自己实现的深拷贝    cout &lt;&lt; &quot;调用Person类的拷贝构造函数&quot; &lt;&lt; endl;    name = p.name;    age = new int(*p.age);&#125;void func() &#123;Person p0(&quot;LiHua&quot;, 19);Person p1(p0);*p1.age = 10;cout &lt;&lt; *p0.age &lt;&lt; endl;//输出19cout &lt;&lt; *p1.age &lt;&lt; endl;//输出10 &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-5初始化列表"><a href="#2-5初始化列表" class="headerlink" title="2.5初始化列表"></a>2.5初始化列表</h4><ul><li><p>作用：C++为构造函数提供了初始化列表语法，用来初始化属性（推荐使用该方法）</p></li><li><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:string name;int age;Person():name(<span class="meta-string">&quot;&quot;</span>),age(0) &#123;<span class="comment">//注意C++中不能把NULL赋值给对象(string实质上是一个class类)（不同于Java）cout &lt;&lt; &quot;调用Person类的无参构造函数&quot; &lt;&lt; endl;&#125;Person(string _name, int _age):name(_name),age(_age) &#123;cout &lt;&lt; &quot;调用Person类的有参构造函数&quot; &lt;&lt; endl;//传统实现同样功能的做法（实际是为属性赋值而不是初始化属性）（效率上相对低）/*name = _name;age = _age;*/&#125;~Person() &#123;cout &lt;&lt; &quot;调用Person类的析构函数&quot; &lt;&lt; endl;&#125;&#125;;void func() &#123;Person p0;cout &lt;&lt; p0.name &lt;&lt; endl;cout &lt;&lt; p0.age &lt;&lt; endl;Person p1(&quot;LiHua&quot;,19);cout &lt;&lt; p1.name &lt;&lt; endl;cout &lt;&lt; p1.age &lt;&lt; endl;&#125;int main() &#123;func();&#125;//结果：调用Person类的无参构造函数0调用Person类的有参构造函数LiHua19调用Person类的析构函数调用Person类的析构函数</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-6类对象作为类的成员属性"><a href="#2-6类对象作为类的成员属性" class="headerlink" title="2.6类对象作为类的成员属性"></a>2.6类对象作为类的成员属性</h4><ul><li><p>构造和析构的顺序问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class A &#123;public:A() &#123;cout &lt;&lt; <span class="meta-string">&quot;A的构造函数&quot;</span> &lt;&lt; endl;&#125;~A() &#123;cout &lt;&lt; <span class="meta-string">&quot;A的析构函数&quot;</span> &lt;&lt; endl;&#125;&#125;;class B &#123;public:A a;B() &#123;cout &lt;&lt; <span class="meta-string">&quot;B的构造函数&quot;</span> &lt;&lt; endl;&#125;~B() &#123;cout &lt;&lt; <span class="meta-string">&quot;B的析构函数&quot;</span> &lt;&lt; endl;&#125;&#125;;void func() &#123;B b;&#125;int main() &#123;func();&#125;<span class="comment">//结果A的构造函数B的构造函数B的析构函数A的析构函数</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-7静态成员"><a href="#2-7静态成员" class="headerlink" title="2.7静态成员"></a>2.7静态成员</h4><p>  静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>  静态成员包括：</p><ul><li><p>静态成员变量（属性）</p><ul><li><p>所有该类的对象共享同一份数据</p></li><li><p>在编译阶段分配内存（全局区）</p></li><li><p>必须类内声明，类外定义（若某行代码使得其变量获得内存，则称为定义）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Student &#123;public:string name;int age;static bool hasID; <span class="comment">//类内声明&#125;;bool Student::hasID = true;//类外定义，至于赋不赋予初值都可以void func() &#123;Student stu;cout &lt;&lt; stu.hasID &lt;&lt; endl;//通过对象访问cout &lt;&lt; Student::hasID &lt;&lt; endl;//通过类名访问&#125;int main() &#123;func();&#125;</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态成员函数</p><ul><li>所有该类的对象共享同一份函数（实际上，即便是非静态的成员函数也是所有的该类对象共享同一份，不过非静态成员函数可以通过this指针区别是哪个对象在调用自己，而静态成员函数中没有隐含this指针）</li><li>静态成员函数只能访问静态成员变量（因为静态成员函数中没有this指针）</li><li>静态成员函数既可以在类内声明并定义，也可以类内声明，类外定义</li></ul></li></ul><h3 id="3-C-对象模型"><a href="#3-C-对象模型" class="headerlink" title="3.C++对象模型"></a>3.C++对象模型</h3><ul><li><p>成员变量与成员函数分开存储</p><p>在C++中，对象的成员变量和成员函数是分开存储的，只有非静态成员变量才存储在对象上，其他的都不存储在对象上</p></li><li><p>再补充一个知识点：空类对象所占的内存空间</p><p>当一个类A中没有声明任何成员变量和成员函数时，sizeof(A) = 1。编译器不允许一个类占用的内存空间大小为0，会为它分配1个字节的内存，若不这样做，那么两个类A的实例在内存中将会无法区分。为空类对象分配1字节的内存空间，这样就使得空类的这两个实例得以在内存中占有独一无二的地址。</p></li></ul><h3 id="4-this指针"><a href="#4-this指针" class="headerlink" title="4.this指针"></a>4.this指针</h3><h4 id="4-1this指针概念"><a href="#4-1this指针概念" class="headerlink" title="4.1this指针概念"></a>4.1this指针概念</h4><p>所有的同类对象公用相同一份非静态成员函数的代码，问题是：这块代码本身是如何区分是哪个对象在调用自己的呢？</p><p>C++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象。this指针是隐含在每一个非静态成员函数中的一种指针（当我们调用非静态成员函数时，调用对象的地址会被隐式地传给this指针），this指针不需要定义，直接使用即可。（this指针是一个指针常量，不能修改指向，这点在后面理解const修饰成员函数时会用到）</p><ul><li>用途：<ul><li>当形参和成员属性同名时，可用this指针加以区分</li><li>在类的非静态成员函数中要想返回对象本身，可使用return *this;（这里还要注意区分返回值和返回引用两种方式）</li></ul></li></ul><h4 id="4-2空指针访问成员函数"><a href="#4-2空指针访问成员函数" class="headerlink" title="4.2空指针访问成员函数"></a>4.2空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是要注意有没有使用this指针，如果用到this指针，需要加以判断来保证代码的健壮性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Student &#123;public:string name;int age;void showClassName()&#123;cout <span class="meta-string">&lt;&lt; &quot;Student&quot; &lt;&lt; endl;&#125;void showNameAndAge() &#123;cout &lt;&lt; name &lt;&lt; endl;//默认转换成this-&gt;</span>namecout <span class="meta-string">&lt;&lt; age &lt;&lt; endl;//同理 this-&gt;</span>age&#125;&#125;;void func() &#123;Student* stu = NULL;stu-&gt;showClassName();<span class="comment">//stu-&gt;showNameAndAge(); 报错，原因是用到了this指针，当前的this是NULL&#125;int main() &#123;func();&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="4-3const修饰成员函数"><a href="#4-3const修饰成员函数" class="headerlink" title="4.3const修饰成员函数"></a>4.3const修饰成员函数</h4><p>常函数：</p><ul><li>成员函数后加const后被称为常函数</li><li>常函数内部不可以修改一般的成员属性</li><li>常函数内部可以修改带mutable关键字的成员属性</li></ul><p>常对象：</p><ul><li>声明对象前加const关键字，这种对象称为常对象</li><li>不允许修改常对象的普通属性，但是可以修改其mutable属性</li><li>常对象只能调用常函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Student &#123;public:string name;mutable int age;int ID;void showNameAndAge() const&#123;<span class="comment">//实际上const修饰的是this指针，这样this指针就成为了指向常量的指针常量，自然不能再修改指向对象的内容age = 20;//ID = 370784; 报错：表达式必须为可修改的左值cout &lt;&lt; name &lt;&lt; endl;cout &lt;&lt; age &lt;&lt; endl;&#125;void showClassName() &#123;cout &lt;&lt; &quot;Student&quot; &lt;&lt; endl;&#125;&#125;;void func() &#123;const Student stu;stu.age = 10;//可以修改mutable属性stu.showNameAndAge();//stu.ID = 101; 不允许修改常对象的一般属性//stu.showClassName(); 不可以调用常对象的非const函数&#125;int main() &#123;func();&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="5-友元"><a href="#5-友元" class="headerlink" title="5.友元"></a>5.友元</h3><p>如果在程序中，有些私有成员也想让类外的一些函数或者其他类进行访问，就需要用到友元技术，其关键字为friend，使用友元的目的就是让类外部的一个函数或者其他类访问该类的私有成员</p><p>友元的三种实现：</p><ul><li>全局函数作友元</li><li>其他类作友元</li><li>其他类的成员函数作友元</li></ul><h4 id="5-1全局函数作友元"><a href="#5-1全局函数作友元" class="headerlink" title="5.1全局函数作友元"></a>5.1全局函数作友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;friend void goodFriend(Person&amp; p);<span class="comment">//友元实现private:string name;int age;public:Person(string name, int age) &#123;this-&gt;name = name;this-&gt;age = age;&#125;&#125;;void goodFriend(Person&amp; p) &#123;//全局函数cout &lt;&lt; &quot;因为我是他的好朋友，他告诉了我他的年龄是：&quot; &lt;&lt; p.age &lt;&lt; endl;&#125;void func() &#123;Person ps = Person(&quot;LiHua&quot;, 19);goodFriend(ps);&#125;int main() &#123;func();&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="5-2其他类作友元"><a href="#5-2其他类作友元" class="headerlink" title="5.2其他类作友元"></a>5.2其他类作友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;friend class goodFriend;<span class="comment">//友元实现private:string name;int age;public:Person(string name, int age) &#123;this-&gt;name = name;this-&gt;age = age;&#125;&#125;;class goodFriend&#123;public:void hisAge(Person&amp; p) &#123;cout &lt;&lt; &quot;我是他的好朋友，他告诉了我他的年龄是：&quot; &lt;&lt; p.age &lt;&lt; endl;&#125;&#125;;void func() &#123;Person ps = Person(&quot;LiHua&quot;, 19);goodFriend gf;gf.hisAge(ps);&#125;int main() &#123;func();&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="5-3成员函数作友元"><a href="#5-3成员函数作友元" class="headerlink" title="5.3成员函数作友元"></a>5.3成员函数作友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;<span class="comment">//下面的类和成员函数的定义顺序必须要注意class Person;//goodFriend类中需要用到Person类，需要先声明一下class goodFriend &#123;public:void hisAge(Person&amp; p);&#125;;//因为Person类还未定义所以不可以在这里定义用到Person类的函数//void goodFriend::hisAge(Person&amp; p) &#123;//cout &lt;&lt; &quot;我是他的好朋友，他告诉了我他的年龄是：&quot; &lt;&lt; p.age &lt;&lt; endl;//&#125;class Person &#123;//Person类的实现friend void goodFriend::hisAge(Person&amp; p);private:string name;int age;public:Person(string name, int age) &#123;this-&gt;name = name;this-&gt;age = age;&#125;&#125;;void goodFriend::hisAge(Person&amp; p) &#123;//现在Person类已经定义，所以可以定义使用到Person类的函数cout &lt;&lt; &quot;我是他的好朋友，他告诉了我他的年龄是：&quot; &lt;&lt; p.age &lt;&lt; endl;&#125;void func() &#123;Person ps = Person(&quot;LiHua&quot;, 19);goodFriend gf;gf.hisAge(ps);&#125;int main() &#123;func();&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="6-运算符重载"><a href="#6-运算符重载" class="headerlink" title="6.运算符重载"></a>6.运算符重载</h3><p>运算符重载的概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="6-1加号运算符重载"><a href="#6-1加号运算符重载" class="headerlink" title="6.1加号运算符重载"></a>6.1加号运算符重载</h4><p>作用：实现两个自定义数据类型的相加运算</p><p>解释：对于内置的数据类型，编译器知道如何进行运算，但是对于自定义类型，编译器就不知道两个对象相加要实现的功能是什么了（比如，是实现全部成员属性各自相加还是部分成员属性各自相加呢，还是其他某种情况呢？编译器是不知道的），这时候就需要我们对加法进行重载</p><ul><li><p>成员函数实现加号运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:int money;<span class="comment">//人持有的钱Person() &#123;this-&gt;money = 0;&#125;Person(int money) &#123;this-&gt;money = money;&#125;//成员函数实现加号运算符重载Person&amp; operator+(Person&amp; p) &#123;Person temp;temp.money = this-&gt;money + p.money;return temp;&#125;&#125;;void func() &#123;Person p1(2);//p1持有两块钱Person p2(3);//p2持有三块钱Person p3 = p1 + p2;//创建对象p3，且p3持有的金钱量是p1和p2两人的金钱和//本质上是Person p3 = p1.operator+(p2);    cout &lt;&lt; p3.money &lt;&lt; endl;;&#125;int main() &#123;func();return 0;&#125;//结果5</span></span></span><br></pre></td></tr></table></figure></li><li><p>全局函数实现加号运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:int money;<span class="comment">//人持有的钱Person() &#123;this-&gt;money = 0;&#125;Person(int money) &#123;this-&gt;money = money;&#125;&#125;;//全局函数实现加号运算符重载Person&amp; operator+(Person&amp; p1, Person&amp; p2) &#123;Person temp;temp.money = p1.money + p2.money;return temp;&#125;void func() &#123;Person p1(2);//p1持有两块钱Person p2(3);//p2持有三块钱Person p3 = p1 + p2;//本质是 Person p3 = operator+(p1, p2);cout &lt;&lt; p3.money &lt;&lt; endl;;&#125;int main() &#123;func();return 0;&#125;//结果5</span></span></span><br></pre></td></tr></table></figure></li><li><p>运算符重载函数也会发生函数重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:int money;<span class="comment">//人持有的钱Person() &#123;this-&gt;money = 0;&#125;Person(int money) &#123;this-&gt;money = money;&#125;&#125;;//全局函数实现加号运算符重载Person&amp; operator+(Person&amp; p1, Person&amp; p2) &#123;Person temp;temp.money = p1.money + p2.money;return temp;&#125;Person&amp; operator+(Person&amp; p, int money) &#123;Person temp;temp.money = p.money + money;return temp;&#125;void func() &#123;Person p1(2);//p1持有两块钱Person p2(3);//p2持有三块钱Person p3 = p1 + p2;//本质是 Person p3 = operator+(p1, p2);Person p4 = p1 + 10;//本质是 Person p4 = operator+(p1, 10);cout &lt;&lt; &quot;p3 = p1 + p2，所以p3.money是&quot; &lt;&lt; p3.money &lt;&lt; endl;cout &lt;&lt; &quot;p4 = p1 + 10，所以p4.money是&quot; &lt;&lt; p4.money &lt;&lt; endl;&#125;int main() &#123;func();return 0;&#125;//结果p3 = p1 + p2，所以p3.money是5p4 = p1 + 10，所以p4.money是12思考：通过成员函数如何实现p4 = p1 + 10呢? 解：    Person&amp; operator+(int money) &#123;Person temp;temp.money = this-&gt;money + money;return temp;&#125;</span></span></span><br></pre></td></tr></table></figure></li><li><p>总结：</p><ul><li>总结1：对于运算内置的数据类型的运算符，是不可以改变的（比如想通过运算符重载实现 1+1=0 这是不可以的）</li><li>总结2：不要滥用运算符重载（比如加号运算符重载中实际实现了减法运算等，引起不必要的误会）</li></ul></li></ul><h4 id="6-2左移运算符”-lt-lt-”重载"><a href="#6-2左移运算符”-lt-lt-”重载" class="headerlink" title="6.2左移运算符”&lt;&lt;”重载"></a>6.2左移运算符”&lt;&lt;”重载</h4><p>作用：实现自定义数据类型的输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:string name;int age;Person(string name, int age) &#123;this-&gt;name = name;this-&gt;age = age;&#125;<span class="comment">//成员函数无法实现 cout&lt;&lt;p ，只能实现 p&lt;&lt;cout&#125;;//全局函数实现void operator&lt;&lt;(ostream &amp;myout, Person&amp; p) &#123;//因为cout全局只能有一个，不能创建一个新的，所以用引用方式传递//本质是 operator&lt;&lt;(myout,p) 因为是引用方式传递的，所以myout是cout的别名，是同一个对象//这样就可以简化为 myout&lt;&lt;pcout &lt;&lt; p.name &lt;&lt; &quot; &quot; &lt;&lt; p.age;&#125;void func() &#123;Person ps(&quot;LiHua&quot;, 20);cout &lt;&lt; ps; //现在还不可以多个&lt;&lt;连续输出,连续输出需要改进    //本质上是 operator&lt;&lt;(cout,ps);    //简化为 cout &lt;&lt; ps&#125;int main() &#123;func();return 0;&#125;//********************************************************************************************************************//********************************************************改进********************************************************#include&lt;iostream&gt;using namespace std;class Person &#123;public:string name;int age;Person(string name, int age) &#123;this-&gt;name = name;this-&gt;age = age;&#125;//成员函数无法实现 cout&lt;&lt;p ，只能实现 p&lt;&lt;cout&#125;;//全局函数实现ostream&amp; operator&lt;&lt;(ostream &amp;myout, Person&amp; p) &#123;//同样因为cout只能有一个，所以以引用方式返回myout &lt;&lt; p.name &lt;&lt; &quot; &quot; &lt;&lt; p.age;return myout;&#125;void func() &#123;Person ps(&quot;LiHua&quot;, 20);cout &lt;&lt; ps &lt;&lt; &quot;连续输出(链式编程思想)&quot; &lt;&lt; endl;&#125;int main() &#123;func();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><ul><li>总结：重载左移运算符配合友元（当类的属性为private时，就需要把重载运算符函数声明为类的友元）可以实现输出自定义数据类型</li></ul><h4 id="6-3自增运算符重载"><a href="#6-3自增运算符重载" class="headerlink" title="6.3自增运算符重载"></a>6.3自增运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:int money;Person() &#123;money = 0;&#125;Person(int money) &#123;this-&gt;money = money;&#125;Person&amp; operator++() &#123;<span class="comment">//前置自增 可以实现连续自增this-&gt;money++;return *this;&#125;const Person operator++(int) &#123; //占位参数只能用int，通过它告诉编译器这是后置自增Person temp = *this; //暂存this-&gt;money++;return temp;//返回暂存对象（局部变量），不能以引用方式返回，只能用值方式返回，拷贝一份副本，这也是为什么后置自增速度比前置递自慢的原因&#125;&#125;;void func() &#123;Person ps(10);cout &lt;&lt; (++(++ps)).money &lt;&lt; endl;//前置自增 可以实现连续自增cout &lt;&lt; ps.money &lt;&lt; endl;Person p(20);cout &lt;&lt; (p++).money &lt;&lt; endl;//后置自增不可以实现连续自增 因为第二次自增操作是对返回的新对象temp的副本的自增cout &lt;&lt; p.money &lt;&lt; endl;&#125;int main() &#123;func();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>总结：前置递增以引用方式返回，后置递增以值方式返回</p><h4 id="6-4赋值运算符重载"><a href="#6-4赋值运算符重载" class="headerlink" title="6.4赋值运算符重载"></a>6.4赋值运算符重载</h4><p>注意点（学习侯捷C++后补充的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;Person p2 = p1; <span class="comment">//这是拷贝构造的隐式转换（p2刚被创建） 等同于Person p2(p1);Person p3;p3 = p2;//这是赋值操作（p3被赋值）</span></span><br></pre></td></tr></table></figure><p>C++编译器实际上除了给类添加默认构造函数、默认析构函数、默认拷贝构造函数外，还会提供一个默认的赋值运算符“=”的重载函数，实现对属性的拷贝。</p><ul><li><p>但这种拷贝是浅拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:int* age;Person(int age) &#123;this-&gt;age = new int(age);&#125;    <span class="comment">/*打开这个析构函数后，程序会报错，因为func()函数执行结束时会重复释放同一块内存空间（转至 类和对象-&gt;2.4深拷贝与浅拷贝）    ~Person() &#123;if (this-&gt;age != NULL) &#123;delete this-&gt;age;this-&gt;age = NULL;&#125;&#125;*/</span>&#125;;void func() &#123;Person ps(18);Person p(20);cout &lt;&lt; ps.age &lt;&lt; endl;cout &lt;&lt; p.age &lt;&lt; endl;cout &lt;&lt; *ps.age &lt;&lt; endl;cout &lt;&lt; *p.age &lt;&lt; endl;ps = p;<span class="comment">//浅拷贝cout &lt;&lt; ps.age &lt;&lt; endl;cout &lt;&lt; p.age &lt;&lt; endl;cout &lt;&lt; *ps.age &lt;&lt; endl;cout &lt;&lt; *p.age &lt;&lt; endl;&#125;int main() &#123;func();return 0;&#125;//结果013BDA00013BDA301820013BDA30//ps.age指向了p.age所指的内存空间，拷贝的是地址013BDA302020</span></span></span><br></pre></td></tr></table></figure></li><li><p>我们需要自己编写赋值运算符重载函数实现深拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:int* age;Person(int age) &#123;this-&gt;age = new int(age);&#125;~Person() &#123;<span class="meta-keyword">if</span> (this-&gt;age != NULL) &#123;delete this-&gt;age;this-&gt;age = NULL;&#125;&#125;<span class="comment">//成员函数实现 C++规定了operator=只能是成员函数Person&amp; operator=(Person&amp; p) &#123;*this-&gt;age = *p.age;return *this;&#125;&#125;;void func() &#123;Person ps(18);Person p(20);cout &lt;&lt; ps.age &lt;&lt; endl;cout &lt;&lt; p.age &lt;&lt; endl;cout &lt;&lt; *ps.age &lt;&lt; endl;cout &lt;&lt; *p.age &lt;&lt; endl;ps = p;//深拷贝cout &lt;&lt; ps.age &lt;&lt; endl;cout &lt;&lt; p.age &lt;&lt; endl;cout &lt;&lt; *ps.age &lt;&lt; endl;cout &lt;&lt; *p.age &lt;&lt; endl;        //也可以实现下面的链式赋值操作    Person p1(10);Person p2(20);Person p3(0);p3 = p2 = p1;cout &lt;&lt; p1.age &lt;&lt; endl;cout &lt;&lt; p2.age &lt;&lt; endl;cout &lt;&lt; p3.age &lt;&lt; endl;cout &lt;&lt; *p1.age &lt;&lt; endl;cout &lt;&lt; *p2.age &lt;&lt; endl;cout &lt;&lt; *p3.age &lt;&lt; endl;&#125;int main() &#123;func();return 0;&#125;//结果0110DA000110DA3018200110DA00  0110DA302020//链式赋值操作的结果0127DA000127DA3001274A30101010</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-5关系运算符重载"><a href="#6-5关系运算符重载" class="headerlink" title="6.5关系运算符重载"></a>6.5关系运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:int money;Person(int money) &#123;this-&gt;money = money;&#125;<span class="comment">//成员函数实现bool operator&gt;(Person&amp; p) &#123;return this-&gt;money &gt; p.money ? true : false;&#125;&#125;;////全局函数实现//bool operator&gt;(Person&amp; p1, Person&amp; p) &#123;//return p1.money &gt; p.money ? true : false;//&#125;void func() &#123;Person p1(20);Person p2(10);Person p3(20);Person p4(30);cout &lt;&lt; (p1 &gt; p2) &lt;&lt; endl;cout &lt;&lt; (p1 &gt; p3) &lt;&lt; endl;cout &lt;&lt; (p1 &gt; p4) &lt;&lt; endl;&#125;int main() &#123;func();return 0;&#125;//那么，&lt;，&gt;=，&lt;=，==，!=，它们如何重载呢？</span></span></span><br></pre></td></tr></table></figure><h4 id="6-6函数调用运算符重载"><a href="#6-6函数调用运算符重载" class="headerlink" title="6.6函数调用运算符重载"></a>6.6函数调用运算符重载</h4><ul><li><p>函数调用运算符()也可以重载</p></li><li><p>由于重载后使用的方式非常像函数的调用，因此也被称为仿函数</p></li><li><p>仿函数没有固定的写法，非常灵活</p></li><li><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class AddInteger &#123;public:<span class="comment">//C++规定opeartor()也必须是成员函数int operator()(int num1, int num2) &#123;return num1 + num2;&#125;&#125;;void func() &#123;AddInteger addInt;int sum = addInt(10, 20);cout &lt;&lt; sum;&#125;int main() &#123;func();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-继承"><a href="#7-继承" class="headerlink" title="7.继承"></a>7.继承</h3><h4 id="7-1继承的基本语法"><a href="#7-1继承的基本语法" class="headerlink" title="7.1继承的基本语法"></a>7.1继承的基本语法</h4><ul><li><p>优点：减少代码量，提高代码复用性</p></li><li><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span>继承方式 B&#123;&#125;;<span class="comment">//A称为子类或派生类 B称为父类或基类</span></span><br></pre></td></tr></table></figure></li><li><p>派生类中的成员，包含两大部分：</p><ul><li>一部分是从基类继承过来的，一部分是自己增加的成员</li><li>从基类继承过来的成员表现其共性，而新增的成员体现了其个性</li></ul></li><li><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:string name;int age;&#125;;class Student :public Person &#123;public:int stuID;&#125;;class Teacher :public Person &#123;public:int teaID;&#125;;void func() &#123;Student stu;stu.name = <span class="meta-string">&quot;LiHua&quot;</span>;stu.age = 19;stu.stuID = 120190201;Teacher th;th.name = <span class="meta-string">&quot;WangXiang&quot;</span>;th.age = 37;th.teaID = 220190211;&#125;int main() &#123;func();       return 0;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="7-2继承方式"><a href="#7-2继承方式" class="headerlink" title="7.2继承方式"></a>7.2继承方式</h4><p>继承方式一共有三种：public继承、protected继承、private继承</p><ul><li><p>当public继承的时候，父类中public类型的成员会被继承到子类的public中去，而父类的protected成员也会被继承到子类的protected中去</p></li><li><p>当protected继承的时候，父类中无论是public的还是protected的成员都会被继承到子类的protected中去</p></li><li><p>当private继承的时候，父类中 public 和 protected 的成员都会被继承到子类的private中去</p></li></ul><p><strong>关于父类的private成员</strong>：C++与Java一样，子类会继承父类的全部属性和方法，但是对于父类的private成员，子类不可以直接访问，需要通过由继承父类得到的public成员函数来访问这些成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Father &#123;public:int num1 = 10;protected:<span class="comment">//保护权限的成员可以在子类中访问int num2 = 20;private:int num3 = 30;public:void printInFather() &#123;cout &lt;&lt; num1 &lt;&lt; endl;cout &lt;&lt; num2 &lt;&lt; endl;cout &lt;&lt; num3 &lt;&lt; endl;&#125;&#125;;class Son1 :public Father &#123;//公共继承&#125;;class Son2 :protected Father &#123;//保护继承&#125;;class Son3 :private Father &#123;//私有继承&#125;;class Grandson1 :public Son1 &#123;public:void print() &#123;cout &lt;&lt; num1 &lt;&lt; endl;//num1是Son1类的公共属性cout &lt;&lt; num2 &lt;&lt; endl;//num2是Son1类的保护属性，Grandson1是Son1的子类，可以访问其保护属性//cout &lt;&lt; num3 &lt;&lt; endl;//num3虽然由Father继承给了Son1，但是即使是Son1也不可以直接访问Father的私有属性，Grandson1就更不可以了&#125;&#125;;class Grandson2 :public Son2 &#123;public:void print() &#123;cout &lt;&lt; num1 &lt;&lt; endl;//num1是Son2类的保护属性，Grandson2是Son2的子类，可以访问其保护属性cout &lt;&lt; num2 &lt;&lt; endl;//num2是Son2类的保护属性，Grandson2是Son2的子类，可以访问其保护属性//cout &lt;&lt; num3 &lt;&lt; endl;&#125;&#125;;class Grandson3 :public Son3 &#123;public:void print() &#123;//cout &lt;&lt; num1 &lt;&lt; endl;//num1是Son3类的私有属性//cout &lt;&lt; num2 &lt;&lt; endl;//num2是Son3类的私有属性//cout &lt;&lt; num3 &lt;&lt; endl;&#125;&#125;;void func() &#123;Son1 son1;son1.printInFather();//printInFather()是由继承父类得到的公共成员函数，可以通过这类方法调用父类的私有成员&#125;int main() &#123;func();       return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="7-3继承中的对象模型"><a href="#7-3继承中的对象模型" class="headerlink" title="7.3继承中的对象模型"></a>7.3继承中的对象模型</h4><p>问题：从父类继承过来的成员，哪些存储在子类对象中？</p><p>解答：父类中所有的非静态成员变量都存储在子类对象中，只不过private权限的成员变量不允许子类对象直接访问</p><h4 id="7-4继承中构造和析构的顺序"><a href="#7-4继承中构造和析构的顺序" class="headerlink" title="7.4继承中构造和析构的顺序"></a>7.4继承中构造和析构的顺序</h4><p>子类继承父类后，在我们创建子类对象时，也会调用父类的构造函数</p><p>那么问题来了：父类和子类的构造和析构的顺序是谁先谁后呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Father &#123;public:Father() &#123;cout &lt;&lt; <span class="meta-string">&quot;Father的构造函数&quot;</span> &lt;&lt; endl;&#125;~Father() &#123;cout &lt;&lt; <span class="meta-string">&quot;Father的析构函数&quot;</span> &lt;&lt; endl;&#125;&#125;;class Son :public Father &#123;public:Son() &#123;cout &lt;&lt; <span class="meta-string">&quot;Son的构造函数&quot;</span> &lt;&lt; endl;&#125;~Son() &#123;cout &lt;&lt; <span class="meta-string">&quot;Son的析构函数&quot;</span> &lt;&lt; endl;&#125;&#125;;void func() &#123;Son son;&#125;int main() &#123;func();       return 0;&#125;<span class="comment">//结果Father的构造函数Son的构造函数Son的析构函数Father的析构函数</span></span></span><br></pre></td></tr></table></figure><h4 id="7-5继承中同名成员的处理方式"><a href="#7-5继承中同名成员的处理方式" class="headerlink" title="7.5继承中同名成员的处理方式"></a>7.5继承中同名成员的处理方式</h4><p>问题：当子类与父类中出现同名的成员时，如何通过子类对象，访问子类或父类中同名的成员呢？</p><p>解答：</p><ul><li><p>访问子类中同名成员时，直接访问即可</p></li><li><p>访问继承父类得到的同名成员时，需要加父类作用域</p></li><li><p>（学习侯捷C++后的补充）当子类继承父类后，若子类中没有与父类同名的普通成员函数，我们用子类对象调用函数实际上调用的是父类作用域下的成员函数，但若子类中具有同名的成员函数，我们用子类对象调用的实际上是子类作用域下的成员函数，这时子类对象有两份同名的成员函数，一份是父类下的，一份是子类下的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;...&#125;;<span class="comment">//假设A中有print成员函数，而B中没有B b;b.print();//实际是 b.A::print();//假设B中也有printb.print();//实际是 b.B::print();</span></span><br></pre></td></tr></table></figure></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Father &#123;public:int age;Father() &#123;age = 45;&#125;void fun() &#123;cout &lt;&lt; <span class="meta-string">&quot;Father中的fun()调用&quot;</span> &lt;&lt; endl;&#125;void fun(int num) &#123;cout &lt;&lt; <span class="meta-string">&quot;Father中的fun(int num)调用&quot;</span> &lt;&lt; endl;&#125;&#125;;class Son :public Father &#123;public:int age;Son() &#123;age = 20;&#125;void fun() &#123;cout &lt;&lt; <span class="meta-string">&quot;Son中的fun()调用&quot;</span> &lt;&lt; endl;&#125;&#125;;void func() &#123;Son son;cout &lt;&lt; <span class="meta-string">&quot;Son的age是：&quot;</span> &lt;&lt; son.age &lt;&lt; endl;cout &lt;&lt; <span class="meta-string">&quot;Father的age是：&quot;</span> &lt;&lt; son.Father::age &lt;&lt; endl;son.fun();<span class="comment">//son.fun(100); 错误，因为子类中的fun()会隐藏掉父类中所有的同名成员函数son.Father::fun(100);son.Father::fun();&#125;int main() &#123;func();       return 0;&#125;//结果Son的age是：20Father的age是：45Son中的fun()调用Father中的fun(int num)调用Father中的fun()调用</span></span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>子类对象可以直接访问子类中的同名成员</li><li>子类对象加父类作用域才能访问继承父类得到的同名成员</li><li>当子类与父类存在同名的成员函数时，子类会隐藏掉继承父类得到的所有的同名成员函数，即便参数列表不同，也仍需要加父类作用域才能访问到继承父类得到的同名成员函数</li></ul><h4 id="7-6继承中同名静态成员的处理方式"><a href="#7-6继承中同名静态成员的处理方式" class="headerlink" title="7.6继承中同名静态成员的处理方式"></a>7.6继承中同名静态成员的处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问呢？</p><p>解答：</p><p>静态成员出现同名情况时，处理方法与非静态成员相同</p><ul><li>访问子类中同名成员时，直接访问即可</li><li>访问继承父类得到的同名成员时，需要加父类作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Father &#123;public:static int age;<span class="comment">//staticstatic void fun() &#123;cout &lt;&lt; &quot;Father中的fun()调用&quot; &lt;&lt; endl;&#125;&#125;;int Father::age = 45;class Son :public Father &#123;public:static int age;static void fun() &#123;cout &lt;&lt; &quot;Son中的fun()调用&quot; &lt;&lt; endl;&#125;&#125;;int Son::age = 20;void func() &#123;Son son;cout &lt;&lt; &quot;Son的age是：&quot; &lt;&lt; son.age &lt;&lt; endl;cout &lt;&lt; &quot;Father的age是：&quot; &lt;&lt; son.Father::age &lt;&lt; endl;cout &lt;&lt; &quot;类名方式访问：Son的age是：&quot; &lt;&lt; Son::age &lt;&lt; endl;cout &lt;&lt; &quot;类名方式访问：Father的age是：&quot; &lt;&lt; Son::Father::age &lt;&lt; endl;son.fun();son.Father::fun();Son::fun();Son::Father::fun();&#125;int main() &#123;func();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>总结：同名静态成员处理方式和非静态成员处理方式一样，不过有通过对象访问和通过类名访问两种方式</p><h4 id="7-7多继承"><a href="#7-7多继承" class="headerlink" title="7.7多继承"></a>7.7多继承</h4><p>C++允许一个类继承多个类（这点与Java不同）</p><ul><li><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Father1, <span class="keyword">protected</span> Father2...&#123;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>当多个父类中存在同名成员时，我们通过子类调用该对象继承父类得到的同名成员时，需要加作用域区分</p></li><li><p>实际开发中，不建议使用多继承</p></li></ul><h4 id="7-8虚继承"><a href="#7-8虚继承" class="headerlink" title="7.8虚继承"></a>7.8虚继承</h4><p>菱形继承（钻石继承）概念：</p><ul><li>两个派生类继承同一个基类</li><li>又有某个类继承了这两个派生类</li></ul><p>问题：最后的子类继承到了具有相同意义的两个变量，浪费资源</p><p>解决：使用虚继承解决这个问题</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:int age;&#125;;class Student: public Person&#123;&#125;;class Child :public Person &#123;&#125;;class Pupil: public Student, public Child &#123;&#125;;void func() &#123;Pupil pp;<span class="comment">//pp.age = 12; 报错：Pupil::age不明确pp.Student::age = 12;pp.Child::age = 12;//上述操作可行，但pp中存在两份相同意义（表示年龄）的变量，一份继承自Student，一份继承自Child    //此时sizeof(pp) = 8，因为其中有两份int类型的变量&#125;int main() &#123;func();return 0;&#125;//*************************************************************************//******************************解决方法************************************#include&lt;iostream&gt;using namespace std;class Person &#123;public:int age;&#125;;class Student : virtual public Person &#123;//虚继承 称Person为虚基类&#125;;class Child : virtual public Person &#123;//虚继承&#125;;class Pupil : public Student, public Child &#123;&#125;;void func() &#123;Pupil pp;pp.age = 12;&#125;int main() &#123;func();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="8-多态"><a href="#8-多态" class="headerlink" title="8.多态"></a>8.多态</h3><h4 id="8-1多态的基本概念"><a href="#8-1多态的基本概念" class="headerlink" title="8.1多态的基本概念"></a>8.1多态的基本概念</h4><p>多态分为两类：</p><ul><li>静态多态：函数重载和运算符重载属于静态多态，复用函数和运算符</li><li>动态多态：派生类和虚函数实现运行时（动态）多态</li></ul><p>静态多态和动态多态的区别：</p><ul><li>静态多态的函数地址早绑定-编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定-运行阶段确定函数地址</li></ul><p>动态多态的条件：</p><ul><li>存在继承关系</li><li>子类重写父类中的虚函数（重写：函数的返回值类型 函数名 形参列表完全一致）</li></ul><p>动态多态的使用：需要父类的指针或引用指向子类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Animal &#123;public:virtual void speak() &#123;cout <span class="meta-string">&lt;&lt; &quot;动物叫&quot; &lt;&lt; endl;&#125;&#125;;class Cat :public Animal &#123;void speak() &#123;cout &lt;&lt; &quot;喵喵喵&quot; &lt;&lt; endl;&#125;&#125;;class Dog :public Animal &#123;void speak() &#123;cout &lt;&lt; &quot;汪汪汪&quot; &lt;&lt; endl;&#125;&#125;;void doSpeak(Animal&amp; am) &#123;am.speak();&#125;void func() &#123;Cat cat;Animal&amp; am0 = cat; //父类引用指向一个子类对象am0.speak();Animal* am1 = &amp;cat;//父类指针指向一个子类对象am1-&gt;</span>speak();doSpeak(cat);<span class="comment">//父类引用类型的形式参数接收一个子类对象Animal am2 = cat; //将子类对象赋值给父类变量不能实现多态am2.speak();//打印 动物叫&#125;int main() &#123;func();return 0;&#125;//结果喵喵喵喵喵喵喵喵喵动物叫</span></span></span><br></pre></td></tr></table></figure><h4 id="8-2多态的原理剖析"><a href="#8-2多态的原理剖析" class="headerlink" title="8.2多态的原理剖析"></a>8.2多态的原理剖析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;&#125;&#125;;<span class="comment">//sizeof(Animal) = 1; 因为Animal对象上不会存储任何结构（只有非静态成员变量存储在对象上）</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;&#125;&#125;;<span class="comment">/*sizoeof(Animal) = 4原因是Animal对象上会存放一个vfptr指针（虚函数指针）vfptr指针指向vftable（虚函数表）vftable中存放的是虚函数地址 &amp;Animal::speak*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;&#125;&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123;&#125;;<span class="comment">/*Cat会继承Animal中的全部成员（属性和函数）所以Cat中继承到了vfptr指针，所以sizeof(Cat) = 4同样vfptr指针指向了vftable当Cat不对Animal中的虚函数Animal::speak重写时vftable中存放的是虚函数地址 &amp;Animal::speak*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;&#125;&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123; <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;喵喵喵&quot;</span> &lt;&lt; endl;&#125;&#125;;<span class="comment">/*Cat会继承Animal中的全部成员（属性和函数）所以Cat中继承到了vfptr指针同样vfptr指针指向了vftable但是如果Cat重写了Animal中的虚函数Animal::speakvftable中存放的是虚函数地址 &amp;Cat::speak*/</span><span class="comment">//这种情况下，如果Animal类的引用或者指针指向了Cat类的对象，如下Cat cat;Animal&amp; am = cat;Animal* am = &amp;cat;Animal* am = new Cat;/*就会发生多态，我们用am调用speak函数时，因为对象本身是Cat类的对象，所以调用的是Cat::speak*/</span></span><br></pre></td></tr></table></figure><h4 id="8-3纯虚函数和抽象类"><a href="#8-3纯虚函数和抽象类" class="headerlink" title="8.3纯虚函数和抽象类"></a>8.3纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是无意义的，主要用于调用子类重写的内容，因此可以将虚函数改为纯虚函数，当某个类中有了纯虚函数，该类就被称为抽象类</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名(形参列表) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>抽象类的特点：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则该子类也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Animal &#123;<span class="comment">//抽象类public:virtual void speak() = 0;//纯虚函数(不可以定义，必须由子类定义)&#125;;class Cat :public Animal &#123;&#125;;class Dog :public Animal &#123;void speak() &#123;cout &lt;&lt; &quot;汪汪汪&quot; &lt;&lt; endl;&#125;&#125;;void func() &#123;//Animal am; 报错，原因是抽象类不可以实例化对象//new Animal; 报错，原因是抽象类不可以实例化对象//Cat cat; 报错，原因是Cat类中没有重写Animal的纯虚函数，Cat类也是一个抽象类Dog dog0;//正确Animal* dog1 = new Dog;//发生多态dog1-&gt;speak();&#125;int main() &#123;func();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="8-4虚析构和纯虚析构"><a href="#8-4虚析构和纯虚析构" class="headerlink" title="8.4虚析构和纯虚析构"></a>8.4虚析构和纯虚析构</h4><p>问题：使用多态时，如果子类中有属性开辟到了堆区，那么父类指针（或引用）在释放时无法调用到子类的析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Animal &#123;<span class="comment">//抽象类public:Animal() &#123;cout &lt;&lt; &quot;Animal的构造函数&quot; &lt;&lt; endl;&#125;~Animal() &#123;cout &lt;&lt; &quot;Animal的析构函数&quot; &lt;&lt; endl;&#125;virtual void speak() = 0;//纯虚函数&#125;;class Cat :public Animal &#123;public:string* name;Cat(string name) &#123;cout &lt;&lt; &quot;Cat的构造函数&quot; &lt;&lt; endl;this-&gt;name = new string(name);&#125;~Cat() &#123;cout &lt;&lt; &quot;Cat的析构函数&quot; &lt;&lt; endl;if (this-&gt;name != NULL) &#123;delete this-&gt;name;this-&gt;name = NULL;&#125;&#125;void speak() &#123;cout &lt;&lt; &quot;喵喵喵&quot; &lt;&lt; endl;&#125;&#125;;void func() &#123;Animal* cat = new Cat(&quot;Tom&quot;);cat-&gt;speak();delete cat;&#125;int main() &#123;func();return 0;&#125;//结果Animal的构造函数Cat的构造函数喵喵喵//这里没有调用到Cat类的析构函数Animal的析构函数</span></span></span><br></pre></td></tr></table></figure><p>解决方法：将父类的析构函数改为虚析构或者纯虚析构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;<span class="comment">//虚析构    cout &lt;&lt; &quot;Animal的虚析构&quot; &lt;&lt; endl;&#125;//结果Animal的构造函数Cat的构造函数喵喵喵Cat的析构函数Animal的虚析构class Animal &#123;//抽象类public:Animal() &#123;cout &lt;&lt; &quot;Animal的构造函数&quot; &lt;&lt; endl;&#125;virtual ~Animal() = 0;//纯虚析构函数virtual void speak() = 0;//纯虚函数&#125;;Animal::~Animal() &#123;//纯虚析构函数的实现（也可以在类内部实现）cout &lt;&lt; &quot;Animal的纯虚析构&quot; &lt;&lt; endl;&#125;</span></span><br></pre></td></tr></table></figure><p>虚析构和纯虚析构的共性：</p><ul><li>使得父类指针（或引用）可以释放子类对象中开辟到堆区的属性</li><li>都需要有具体的函数实现（因为父类中也可能存在开辟到堆区的属性，需要通过析构函数释放）</li></ul><p>虚析构和纯虚析构的区别：</p><ul><li>如果某类中存在的是纯虚析构，则该类属于抽象类，无法实例化对象</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束，这些数据就会被释放，通过文件可以将数据保存下来，C++中文件操作需要包含头文件&lt;fstream&gt;（文件流类）</p><p>文件类型分为两类：</p><ul><li>文本文件：文件以文本的ASCII码形式存储在计算机中</li><li>二进制文件：文件以文本的二进制形式存储在计算机中</li></ul><p>三类文件操作：</p><ul><li>ofstream：写文件</li><li>ifstream：读文件</li><li>fstream：读写文件</li></ul><h3 id="1-写文件"><a href="#1-写文件" class="headerlink" title="1.写文件"></a>1.写文件</h3><p>步骤：</p><ol><li>包含头文件 #include&lt;fstream&gt;</li><li>创建流对象 ofstream ofs;</li><li>打开文件 ofs.open(“文件路径”,打开方式);</li><li>写数据 ofs&lt;&lt;”写入的信息”;</li><li>关闭文件 ofs.close();</li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>描述</th></tr></thead><tbody><tr><td>ios::in</td><td>为读取文件而打开文件</td></tr><tr><td>ios::out</td><td>为 写入文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置为文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>先删除文件再创建新的</td></tr><tr><td>ios::binary</td><td>以二进制方式读写文件</td></tr></tbody></table><p>注意：文件打开方式可以利用“|”操作符来配合使用</p><p>例如：ios::binary | ios::out 以二进制方式写文件</p><h3 id="2-读文件"><a href="#2-读文件" class="headerlink" title="2.读文件"></a>2.读文件</h3><p>步骤：</p><ol><li>包含头文件 #include&lt;fstream&gt;</li><li>创建流对象 ifstream ifs;</li><li>打开文件 ifs.open(“文件路径”,打开方式);</li><li>判断是否打开成功 ifs.is_open()</li><li>读数据 四种读取方式</li><li>关闭文件 ofs.close();</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span>using namespace std;int main() &#123;ifstream ifs;ifs.open(<span class="meta-string">&quot;C:\\Users\\74615\\Desktop\\test.txt&quot;</span>, ios::in);<span class="meta-keyword">if</span> (!ifs.is_open()) &#123;cout <span class="meta-string">&lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;&#125;//读数据方式：//第一种：一次读取遇到空格、换行、制表符结束char buf[1024] = &#123; 0 &#125;; int cnt = 1;while (ifs &gt;</span>&gt; buf) &#123;<span class="comment">//读完则返回false cout &lt;&lt; buf &lt;&lt; endl;cout &lt;&lt; &quot;第&quot; &lt;&lt; cnt &lt;&lt; &quot;次读取&quot; &lt;&lt; endl;cnt++;&#125;ifs.close();//第二种：一次读取一行/*char buf[1024] = &#123; 0 &#125;; int cnt = 1;while (ifs.getline(buf,sizeof(buf))) &#123;//读完则返回false cout &lt;&lt; buf &lt;&lt; endl;cout &lt;&lt; &quot;第&quot; &lt;&lt; cnt &lt;&lt; &quot;次读取&quot; &lt;&lt; endl;cnt++;&#125;ifs.close();*///第三种：利用string读取 一次读取一行/*string buf;int cnt = 1;while (getline(ifs,buf)) &#123;cout &lt;&lt; buf &lt;&lt; endl;cout &lt;&lt; &quot;第&quot; &lt;&lt; cnt &lt;&lt; &quot;次读取&quot; &lt;&lt; endl;cnt++;&#125;ifs.close();*///第四种（不常用）：逐字符读取（效率低），这种方式会读到空格、制表符和换行/*char c;int cnt = 1;while ((c = ifs.get()) != EOF) &#123;//读到文件尾则停止循环//这里再交代一下EOF是什么//EOF全称end of file，表示文件末尾cout &lt;&lt; c &lt;&lt; endl;cout &lt;&lt; &quot;第&quot; &lt;&lt; cnt &lt;&lt; &quot;次读取&quot; &lt;&lt; endl;cnt++;&#125;ifs.close();*/return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>如何判断文件是否为空：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;ifs &gt;&gt; ch;<span class="keyword">if</span>(ifs.<span class="built_in">eof</span>())&#123;    cout&lt;&lt;<span class="string">&quot;文件为空&quot;</span>&lt;&lt;endl;&#125;ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h3 id="3-二进制方式写文件"><a href="#3-二进制方式写文件" class="headerlink" title="3.二进制方式写文件"></a>3.二进制方式写文件</h3><p>二进制方式写文件不仅可以操作内置数据类型，还可以操作自定义数据类型</p><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream&amp; <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buffer, <span class="keyword">int</span> len)</span></span>;<span class="comment">//字符指针buffer指向内存中一段存储空间，len是读写的字节数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span>class Person &#123;public:char name[64];int age;&#125;;using namespace std;int main() &#123;ofstream ofs(<span class="meta-string">&quot;C:\\Users\\74615\\Desktop\\test.txt&quot;</span>, ios::out | ios::binary);Person ps = &#123;<span class="meta-string">&quot;LiHua&quot;</span>, 18&#125;;<span class="comment">//结构体初始化方式ofs.write((const char*)&amp;ps, sizeof(ps));ofs.close();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="4-二进制方式读文件"><a href="#4-二进制方式读文件" class="headerlink" title="4.二进制方式读文件"></a>4.二进制方式读文件</h3><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream&amp; <span class="title">read</span><span class="params">(<span class="keyword">char</span>* buffer, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span>class Person &#123;public:char name[64];int age;&#125;;using namespace std;int main() &#123;ifstream ifs(<span class="meta-string">&quot;C:\\Users\\74615\\Desktop\\test.txt&quot;</span>, ios::in | ios::binary);<span class="meta-keyword">if</span> (!ifs.is_open()) &#123;cout &lt;&lt; <span class="meta-string">&quot;打开文件失败&quot;</span> &lt;&lt; endl;&#125;Person ps;ifs.read((char*)&amp;ps, sizeof(ps));cout &lt;&lt; ps.name &lt;&lt; endl;cout &lt;&lt; ps.age &lt;&lt; endl;ifs.close();return 0;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="C-提高"><a href="#C-提高" class="headerlink" title="C++提高"></a>C++提高</h1><ul><li>主要学习C++泛型编程和STL技术</li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>概念：模板就是建立通用的摸具，大大提高复用性</p><h3 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1.函数模板"></a>1.函数模板</h3><ul><li>C++除了面向对象的编程思想外，还有泛型编程思想，主要利用的技术就是模板</li><li>C++提供<strong>函数模板</strong>和<strong>类模板</strong>两种模板机制</li></ul><h4 id="1-1函数模板的使用"><a href="#1-1函数模板的使用" class="headerlink" title="1.1函数模板的使用"></a>1.1函数模板的使用</h4><p>函数模板的作用：建立一个通用函数，其返回值类型和形参类型可以不具体确定，而是用一个虚拟的类型来代替</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;函数声明或定义;<span class="comment">/*解释：template -- 声明创建模板typename -- 表明后面的符号T是一种数据类型，可以用class代替T -- 通用数据类型，名称自定义，通常使用大写字母*/</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;template<span class="meta-string">&lt;typename T&gt;</span> <span class="comment">//typename可以用class替换void mySwap(T&amp; num1, T&amp; num2) &#123;T temp = num1;num1 = num2;num2 = temp;&#125;void func() &#123;int a = 10;int b = 20;//函数模板使用方法//方法1：自动类型推导//mySwap(a, b);//根据a和b的类型推导出T类型为int//方法2：显式指定类型mySwap&lt;int&gt;(a, b);//显式指定出T类型就是int类型cout &lt;&lt; a &lt;&lt; endl;cout &lt;&lt; b &lt;&lt; endl;//double a = 10.2;//double b = 20.1;//mySwap(a, b);//cout &lt;&lt; a &lt;&lt; endl;//cout &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123;func();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>自动类型推导，必须推导出一致的数据类型T才可以使用（如上例中若a，b的类型不一致，则会报错）</li><li>模板必须确定了T的类型才可以使用（如当我们无法通过形参自动类型推导出T的类型时，我们必须显式指定T类型才可以使用函数）</li></ul><h4 id="1-2函数模板与普通函数的区别"><a href="#1-2函数模板与普通函数的区别" class="headerlink" title="1.2函数模板与普通函数的区别"></a>1.2函数模板与普通函数的区别</h4><p>区别：</p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果采用自动类型推导，不会发生隐式类型转换</li><li>函数模板采用显式指定类型，才会发生隐式类型转换</li></ul><h4 id="1-3函数模板与普通函数调用规则"><a href="#1-3函数模板与普通函数调用规则" class="headerlink" title="1.3函数模板与普通函数调用规则"></a>1.3函数模板与普通函数调用规则</h4><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数（即便普通函数只是声明，没有定义，也不会调用函数模板，而是报错）</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;template<span class="meta-string">&lt;typename T&gt;</span>T getSum(T num1, T num2) &#123;cout <span class="meta-string">&lt;&lt; &quot;函数模板&quot; &lt;&lt; endl;return num1 + num2;&#125;template&lt;typename T&gt;</span>T getSum(T num1, T num2, T num3) &#123;cout <span class="meta-string">&lt;&lt; &quot;函数模板（三数之和）&quot; &lt;&lt; endl;return num1 + num2 + num3;&#125;int getSum(int num1, int num2) &#123;cout &lt;&lt; &quot;普通函数&quot; &lt;&lt; endl;return num1 + num2;&#125;void func() &#123;int a = 10;int b = 20;int c = 30;cout &lt;&lt; getSum(a, b) &lt;&lt; endl;//优先调用普通函数cout &lt;&lt; getSum&lt;&gt;</span>(a, b) &lt;&lt; endl;<span class="comment">//通过空模板参数列表强制调用函数模板cout &lt;&lt; getSum(a, b, c) &lt;&lt; endl;//函数模板也可以发生重载double d = 10.2;double f = 20.1;cout &lt;&lt; getSum(d, f) &lt;&lt; endl;//函数模板可以更好地匹配时，会被优先调用&#125;int main() &#123;func();return 0;&#125;//结果普通函数30函数模板30函数模板（三数之和）60函数模板30.3</span></span></span><br></pre></td></tr></table></figure><h4 id="1-4模板的局限性"><a href="#1-4模板的局限性" class="headerlink" title="1.4模板的局限性"></a>1.4模板的局限性</h4><p>局限性：模板的通用性并不是万能的。例如，当我们传入两个数组或者自定义数据类型，让他们完成赋值、比较、输出等操作时，代码是无法正常运行的</p><p>解决方法：C++提供了模板的重载，可以为这些特定的类型提供具体的模板</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class Person &#123;public:string name;int age;Person(string name, int age) &#123;this-&gt;name = name;this-&gt;age = age;&#125;&#125;;template<span class="meta-string">&lt;typename T&gt;</span>bool compare(T&amp; a,T&amp; b) &#123;return a == b;&#125;<span class="comment">//具体化Person类型版本的函数实现，可以优先被调用//当我们传入的参数为Person类型时，优先执行的是下面的函数template&lt;&gt; bool compare(Person&amp; p1,Person&amp; p2) &#123;return p1.name == p2.name &amp;&amp; p1.age == p2.age;&#125;void func() &#123;Person p1(&quot;LiHua&quot;, 17);Person p2(&quot;LiHua&quot;, 17);bool flag = compare(p1, p2);cout &lt;&lt; flag &lt;&lt; endl;&#125;int main() &#123;func();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以使得自定义类型通用化</li><li>学习模板不是为了编写模板，而是能够运用STL中提供的模板，即为学习STL做铺垫</li></ul><h3 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2.类模板"></a>2.类模板</h3><h4 id="2-1类模板的使用"><a href="#2-1类模板的使用" class="headerlink" title="2.1类模板的使用"></a>2.1类模板的使用</h4><p>类模板的作用：</p><ul><li>建立一个通用类，类中成员变量和形参的数据类型可以不具体确定，而是用一个虚拟的类型来代表</li></ul><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;类的定义<span class="comment">/*解释：template -- 声明创建模板typename -- 表明T是一种数据类型，可以用class代替T -- 通用数据类型，名称自定义，通常使用大写字母*/</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;<span class="comment">//日期类//因为我们的年月日分别可以是中文(字符串类型)也可以是数字(int类型)，所以我们采用类模板template&lt;class Y,class M,class D&gt;class Date &#123;public:Y year;M month;D day;Date(Y year, M month, D day) &#123;this-&gt;year = year;this-&gt;month = month;this-&gt;day = day;&#125;void print() &#123;cout &lt;&lt; &quot;[year]: &quot; &lt;&lt; this-&gt;year &lt;&lt; endl;cout &lt;&lt; &quot;[month]: &quot; &lt;&lt; this-&gt;month &lt;&lt; endl;cout &lt;&lt; &quot;[day]: &quot; &lt;&lt; this-&gt;day &lt;&lt; endl;&#125;&#125;;void func() &#123;Date&lt;string,int,string&gt; dt0(&quot;二零二一年&quot;, 2, &quot;十一号&quot;);Date&lt;string, string, string&gt; dt1(&quot;二零二一年&quot;, &quot;二月&quot;, &quot;十一号&quot;);Date&lt;int, int, int&gt; dt2(2021, 2, 11);dt0.print();cout &lt;&lt; endl;dt1.print();cout &lt;&lt; endl;dt2.print();&#125;int main() &#123;func();return 0;&#125;//结果[year]: 二零二一年[month]: 2[day]: 十一号[year]: 二零二一年[month]: 二月[day]: 十一号[year]: 2021[month]: 2[day]: 11</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2类模板与函数模板的区别"><a href="#2-2类模板与函数模板的区别" class="headerlink" title="2.2类模板与函数模板的区别"></a>2.2类模板与函数模板的区别</h4><p>区别：</p><ul><li><p>类模板没有自动类型推导的使用方式，必须显式指定类型</p></li><li><p>类模板的模板参数列表可以有默认参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>, <span class="keyword">class</span> <span class="title">M</span>, <span class="keyword">class</span> <span class="title">D</span> =</span> <span class="keyword">int</span>&gt;<span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span><span class="keyword">public</span>:Y year;M month;D day;<span class="built_in">Date</span>(Y year, M month, D day) &#123;<span class="keyword">this</span>-&gt;year = year;<span class="keyword">this</span>-&gt;month = month;<span class="keyword">this</span>-&gt;day = day;&#125;&#125;;<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="function">Date&lt;string, <span class="keyword">int</span>&gt; <span class="title">dt0</span><span class="params">(<span class="string">&quot;二零二一年&quot;</span>, <span class="number">2</span>, <span class="number">11</span>)</span></span>;    <span class="comment">//这样我们就可以不显式指定D的类型，而默认D类型就是int类型&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3类模板中成员函数的创建时机"><a href="#2-3类模板中成员函数的创建时机" class="headerlink" title="2.3类模板中成员函数的创建时机"></a>2.3类模板中成员函数的创建时机</h4><p>类模板中成员函数和普通类中成员函数的创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数并不是一开始就创建的，只有在调用时才去创建</li></ul><h4 id="2-4类模板对象做函数参数"><a href="#2-4类模板对象做函数参数" class="headerlink" title="2.4类模板对象做函数参数"></a>2.4类模板对象做函数参数</h4><ul><li>学习使用类模板的实例对象，向函数传参的方式</li></ul><p>一共有3种传入方式：</p><ul><li>指定传入的类型：直接显示对象的数据类型（使用最广泛）</li><li>参数模板化：将对象中的参数变为模板进行传递</li><li>整个类模板化：将对象的类型模板化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;template<span class="meta-string">&lt;class T1,class T2&gt;</span>class complex &#123;public:complex(T1 r = 0.0, T2 i = 0.0):real(r), imag(i) &#123;&#125;T1 get_real() &#123;return real;&#125;T2 get_imag() &#123;return imag;&#125;void show_complex() const &#123;cout <span class="meta-string">&lt;&lt; &quot;( &quot; &lt;&lt; real &lt;&lt; &quot; , &quot; &lt;&lt; imag &lt;&lt; &quot; )&quot; &lt;&lt; endl;&#125;private:T1 real;T2 imag;&#125;;//指定传入类型void print1_complex(const complex&lt;double, int&gt;</span>&amp; c) &#123;c.show_complex();&#125;void test01() &#123;complex<span class="meta-string">&lt;double, int&gt;</span>c(2.1, 3);print1_complex(c);&#125;<span class="comment">//参数模板化template&lt;class T1,class T2&gt;void print2_complex(const complex&lt;T1, T2&gt;&amp; c) &#123;c.show_complex();&#125;void test02() &#123;complex&lt;double, int&gt;c(-2.1, 3);print2_complex(c);&#125;//类模板化template&lt;class T&gt;void print3_complex(const T&amp; c) &#123;c.show_complex();&#125;void test03() &#123;complex&lt;double, int&gt;c(-2.1, -3);print3_complex(c);&#125;int main() &#123;test03();return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-5类模板与继承"><a href="#2-5类模板与继承" class="headerlink" title="2.5类模板与继承"></a>2.5类模板与继承</h4><p>当类模板碰到继承时，需要注意：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定父类中T的类型，需要将子类也写为类模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;template<span class="meta-string">&lt;class T&gt;</span>class AA &#123;public:AA() &#123;cout <span class="meta-string">&lt;&lt; typeid(T).name() &lt;&lt; endl;&#125;T a;&#125;;class BB :public AA&lt;int&gt;</span> &#123;&#125;;template<span class="meta-string">&lt;class T&gt;</span>class CC :public AA<span class="meta-string">&lt;T&gt;</span> &#123;&#125;;int main() &#123;BB b;CC<span class="meta-string">&lt;double&gt;</span> c;&#125;<span class="comment">//结果intdouble</span></span></span><br></pre></td></tr></table></figure><h4 id="2-6类模板成员函数的类外实现"><a href="#2-6类模板成员函数的类外实现" class="headerlink" title="2.6类模板成员函数的类外实现"></a>2.6类模板成员函数的类外实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;template<span class="meta-string">&lt;typename T1, typename T2&gt;</span>class complex &#123;public:complex(T1 r = 0, T2 i = 0);<span class="comment">//类内声明complex(const complex&amp; c):real(c.real),imag(c.imag) &#123;&#125;complex conj();//类内声明private:T1 real;T2 imag;&#125;;//构造函数类外定义template&lt;class T1,class T2&gt;complex&lt;T1,T2&gt;::complex(T1 r ,T2 i)//（函数默认参数值在声明或定义中只能出现一次）:real(r), imag(i) &#123;&#125;//成员函数类外定义template&lt;class T1,class T2&gt;complex&lt;T1,T2&gt; complex&lt;T1, T2&gt;::conj()&#123;return complex(real, -imag);&#125;</span></span></span><br></pre></td></tr></table></figure><p>总结：类模板成员函数和构造函数在类外实现时，需要对该类的类型加模板参数，比如返回值类型，参数类型，作用域等</p><h4 id="2-7类模板分文件编写"><a href="#2-7类模板分文件编写" class="headerlink" title="2.7类模板分文件编写"></a>2.7类模板分文件编写</h4><p>问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p><p>解决：</p><ul><li>方式1：将原本包含.h文件改为包含.cpp源文件（原因是类模板中成员函数是在当调用这个函数时才被创建，当包含.h文件时，编译器不会到.cpp中去找函数的实现，而当我们改为包含.cpp文件时编译器就会看到这些函数的实现，然后又通过.cpp中的include.h命令看到了.h中的代码）</li><li>方式2（常用）：将声明和实现写在同一个文件中，并更改后缀为.hpp，hpp是约定俗成的名称（当使用hpp时通常是在使用类模板的分文件编写），并不是强制的</li></ul><h4 id="2-8类模板和友元"><a href="#2-8类模板和友元" class="headerlink" title="2.8类模板和友元"></a>2.8类模板和友元</h4><p>掌握类模板配合友元函数的类内和类外实现</p><ul><li><p>全局函数类内实现（推荐用这个，语法简单）：直接在类内声明友元即可</p></li><li><p>全局函数类外实现：需要提前让编译器知道全局函数的存在</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;template<span class="meta-string">&lt;class T1, class T2&gt;</span>class Person;<span class="comment">//下面的函数用到person类，提前声明template&lt;class T1, class T2&gt;void print02_person(const Person&lt;T1, T2&gt;&amp; p); //提前声明函数template&lt;class T1,class T2&gt;class Person &#123;//全局函数类内实现friend void print01_person(const Person&lt;T1, T2&gt;&amp; p) &#123;cout &lt;&lt; &quot;&#123;&quot; &lt;&lt; p.m_name &lt;&lt; &quot;,&quot; &lt;&lt; p.m_age &lt;&lt; &quot;&#125;&quot; &lt;&lt; endl;&#125;friend void print02_person&lt;&gt;(const Person&lt;T1, T2&gt;&amp; p);//加&lt;&gt;表明这是个函数模板public:Person(T1 name, T2 age):m_name(name), m_age(age) &#123;&#125;private:T1 m_name;T2 m_age;&#125;;template&lt;class T1, class T2&gt;void print02_person(const Person&lt;T1, T2&gt;&amp; p) &#123;//函数定义cout &lt;&lt; &quot;&#123;&quot; &lt;&lt; p.m_name &lt;&lt; &quot;,&quot; &lt;&lt; p.m_age &lt;&lt; &quot;&#125;&quot; &lt;&lt; endl;&#125;void test01() &#123;Person&lt;string, int&gt; p(&quot;Lihua&quot;, 19);print01_person(p);print02_person(p);&#125;int main() &#123;test01();    return 0;&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><h3 id="1-STL的诞生"><a href="#1-STL的诞生" class="headerlink" title="1.STL的诞生"></a>1.STL的诞生</h3><ul><li>长期以来，软件界都希望建立一种可以被重复利用的东西</li><li>C++面向对象和泛型编程的思想，目的就是提高代码的复用性</li><li>大多数情况下，数据结构和算法未能有一套标准，导致进行了大量的重复工作</li><li>为了建立数据结构和算法的一套统一标准，诞生了STL</li></ul><h3 id="2-STL基本概念"><a href="#2-STL基本概念" class="headerlink" title="2.STL基本概念"></a>2.STL基本概念</h3><ul><li>STL（Standard Template Library，标准模板库）</li><li>STL在广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）</li><li>容器和算法之间通过迭代器连接</li><li>sTL几乎所有的代码都在用了类模板或函数模板</li></ul><h3 id="3-STL六大组件"><a href="#3-STL六大组件" class="headerlink" title="3.STL六大组件"></a>3.STL六大组件</h3><p>STL大体上分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据</li><li>算法：各种常用算法，如sort、find、copy、for_each等</li><li>迭代器：容器与算法之间的粘合剂</li><li>仿函数：行为类似函数，可作为算法的某种策略</li><li>适配器（配接器）：一种用于修饰容器、仿函数或者迭代器接口的东西</li><li>空间配置器：负责空间的配置和管理</li></ol><h3 id="4-STL中的容器、算法、迭代器"><a href="#4-STL中的容器、算法、迭代器" class="headerlink" title="4.STL中的容器、算法、迭代器"></a>4.STL中的容器、算法、迭代器</h3><ul><li><p>容器：</p><p>STL容器就是将运用最广泛的一些数据结构实现出来</p><p>常用的数据结构有：数组、链表、树、栈、队列、集合、映射表等</p><p>这些容器分为序列式容器和关联式容器两种“</p><ul><li>序列式容器：容器中每个元素都有固定的位置</li><li>关联式容器：元素之间没有严格的物理顺序关系</li></ul></li><li><p>算法：</p><p>通过有限的步骤解决逻辑或数学上的问题，我们称之为算法</p><p>算法分为：质变算法和非质变算法</p><ul><li>质变算法：运算过程中会改变区间内元素的内容，例如拷贝，替换，删除等</li><li>非质变算法：运算过程中不会改变区间内的元素内容，例如查找、计数、遍历、寻找极值等</li></ul></li><li><p>迭代器：容器和算法之间的粘合剂</p><ul><li><p>提供一种方法，使其能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式</p></li><li><p>每个容器都有自己专属的迭代器</p></li><li><p>算法要通过迭代器才能访问容器中的元素</p></li><li><p>迭代器的使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p></li><li><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、!=</td></tr><tr><td>输出迭代器</td><td>对数据的只写操作</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、!=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器为双向迭代器和随机访问迭代器</p></li></ul></li></ul><h3 id="5-容器算法迭代器初识"><a href="#5-容器算法迭代器初识" class="headerlink" title="5.容器算法迭代器初识"></a>5.容器算法迭代器初识</h3><h4 id="5-1vector存放内置数据类型"><a href="#5-1vector存放内置数据类型" class="headerlink" title="5.1vector存放内置数据类型"></a>5.1vector存放内置数据类型</h4><ul><li>容器：vector</li><li>算法：for_each</li><li>迭代器：vector&lt;int&gt;::iterator</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>using namespace std;template<span class="meta-string">&lt;class T&gt;</span>void print_T(T val) &#123;cout <span class="meta-string">&lt;&lt; val &lt;&lt; endl;&#125;void test01() &#123;//创建存放内置数据类型int的容器vvector&lt;int&gt;</span> v;<span class="comment">//向容器中添加数据for (int i = 0; i &lt; 5; i++) &#123;v.push_back(i*i);&#125;//通过迭代器访问容器中的数据vector&lt;int&gt;::iterator it_begin = v.begin();//起始迭代器 指向容器v的第一个元素vector&lt;int&gt;::iterator it_end = v.end();//尾后迭代器 指向最后一个元素的后一个位置//遍历方式1while (it_begin != it_end) &#123;cout &lt;&lt; *it_begin &lt;&lt; endl;it_begin++;&#125;//遍历方式2for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; endl;&#125;//遍历方式3(利用STL中的算法for_each)for_each(v.begin(), v.end(), print_T&lt;int&gt;);&#125;int main() &#123;test01();&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="5-2vector存放自定义数据类型"><a href="#5-2vector存放自定义数据类型" class="headerlink" title="5.2vector存放自定义数据类型"></a>5.2vector存放自定义数据类型</h4><p>complex.h文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>using namespace std;class complex &#123;public:complex(int real = 0, int imag = 0):m_real(real), m_imag(imag) &#123;&#125;int get_real() const &#123;return m_real;&#125;int get_imag() const &#123;return m_imag;&#125;private:int m_real;int m_imag;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; os, const complex&amp; c) &#123;os &lt;&lt; <span class="meta-string">&quot;(&quot;</span> &lt;&lt; c.get_real() &lt;&lt; <span class="meta-string">&quot;,&quot;</span> &lt;&lt; c.get_imag() &lt;&lt; <span class="meta-string">&quot;)&quot;</span>;return os;&#125;</span></span><br></pre></td></tr></table></figure><p>main.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&quot;complex.h&quot;</span>using namespace std;template<span class="meta-string">&lt;class T&gt;</span>void print_T(T val) &#123;cout <span class="meta-string">&lt;&lt; val &lt;&lt; endl;&#125;void test01() &#123;//创建存放内置数据类型int的容器vvector&lt;complex&gt;</span> v;<span class="comment">//向容器中添加数据for (int i = 0; i &lt; 5; i++) &#123;v.push_back(complex(i*i,i));&#125;//通过迭代器访问容器中的数据vector&lt;complex&gt;::iterator it_begin = v.begin();//起始迭代器 指向容器v的第一个元素vector&lt;complex&gt;::iterator it_end = v.end();//尾后迭代器 指向最后一个元素的后一个位置//遍历方式1while (it_begin != it_end) &#123;cout &lt;&lt; *it_begin &lt;&lt; endl;it_begin++;&#125;//遍历方式2for (vector&lt;complex&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;cout &lt;&lt; *it &lt;&lt; endl;&#125;//遍历方式3(利用STL中的算法for_each)for_each(v.begin(), v.end(), print_T&lt;complex&gt;);&#125;int main() &#123;test01();&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="5-3容器嵌套容器"><a href="#5-3容器嵌套容器" class="headerlink" title="5.3容器嵌套容器"></a>5.3容器嵌套容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span>#<span class="meta-keyword">include</span><span class="meta-string">&quot;complex.h&quot;</span>using namespace std;void test01() &#123;vector<span class="meta-string">&lt;vector&lt;int&gt;</span>&gt; v;<span class="comment">//添加元素for (int i = 0; i &lt; 5; i++) &#123;vector&lt;int&gt; vj;for (int j = 0; j &lt; 4; j++) &#123;vj.push_back((i+1)*(j+1));&#125;v.push_back(vj);&#125;//遍历for (vector&lt;vector&lt;int&gt;&gt;::iterator it_i = v.begin(); it_i != v.end(); it_i++) &#123;cout &lt;&lt; &quot;&#123; &quot;;for (vector&lt;int&gt;::iterator it_j = (*it_i).begin(); it_j != (*it_i).end(); it_j++) &#123;cout &lt;&lt; *it_j &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt;&quot;&#125;&quot;&lt;&lt; endl;&#125;&#125;int main() &#123;test01();&#125;</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-基础&quot;&gt;&lt;a href=&quot;#C-基础&quot; class=&quot;headerlink&quot; title=&quot;C++基础&quot;&gt;&lt;/a&gt;C++基础&lt;/h1&gt;&lt;h2 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nginx部署hexo</title>
    <link href="https://yyangjiao.github.io/2021/10/20/nginx%E9%83%A8%E7%BD%B2hexo/"/>
    <id>https://yyangjiao.github.io/2021/10/20/nginx%E9%83%A8%E7%BD%B2hexo/</id>
    <published>2021-10-20T08:09:42.000Z</published>
    <updated>2021-10-20T08:19:23.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>执行下述命令安装nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><h2 id="修改root"><a href="#修改root" class="headerlink" title="修改root"></a>修改root</h2><ul><li><p>执行命令编辑<code>/etc/nginx/sites-enabled/default</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure></li><li><p>将<code>root</code>改为<code>/home/yangjiao/blog/public</code>，即博客存放路径下的public目录</p><p><img src="https://gitee.com/yyangjiao/Ubuntu18.04_img_host/raw/master/img6.png"></p></li></ul><h2 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h2><p>执行命令如下完成重启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nginx&quot;&gt;&lt;a href=&quot;#安装nginx&quot; class=&quot;headerlink&quot; title=&quot;安装nginx&quot;&gt;&lt;/a&gt;安装nginx&lt;/h2&gt;&lt;p&gt;执行下述命令安装nginx&lt;/p&gt;
&lt;figure class=&quot;highlight plainte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04设置开机自启动脚本</title>
    <link href="https://yyangjiao.github.io/2021/10/19/Ubuntu18.04%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"/>
    <id>https://yyangjiao.github.io/2021/10/19/Ubuntu18.04%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</id>
    <published>2021-10-19T13:20:21.000Z</published>
    <updated>2021-10-20T08:01:28.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在linux主机上使用hexo搭建博客后，需要实现在开机后自启动hexo服务的功能</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>Ubuntu18.04开始改用systemd管理进程启动</li><li>systemd默认会读取 <code>/etc/systemd/system </code>下的配置文件</li><li>而我们需要的配置文件是<code>/lib/systemd/system/rc-local.service</code>  </li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li><p>编辑<code>/lib/systemd/system/rc-local.service</code>  添加<code>Install</code>区块，如果不添加该区块信息，如<code>WantedBy</code>，<code>Alias</code>等，系统就不认为该文件是一个<code>systemd</code>服务</p><p><img src="https://gitee.com/yyangjiao/Ubuntu18.04_img_host/raw/master/img1.png"></p><ul><li>其中<code>Unit</code>区块主要描述服务的启动顺序以及依赖关系，<code>Service</code>区块主要描述如何启动，<code>Install</code>区块描述如何安装这个服务；</li><li>对<code>Unit</code>区块加以说明：ConditionFileIsExecutable指定了执行的文件，After 表示在 network.target 这个target后面进行执行，也就是网络启动完成之后，会执行<code>/etc/rc.local</code>文件；</li><li>Ubuntu18.04默认没有<code>/etc/rc.local</code>文件，需要自己创建</li></ul></li><li><p>因为systemd 默认读取<code>/etc/systemd/system</code>下的配置文件, 所以需要下述命令将<code>/lib/systemd/system/rc-local.service</code>  链接到<code> /etc/systemd/system 目录下</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/yyangjiao/Ubuntu18.04_img_host/raw/master/img2.png"></p></li><li><p>执行下述命令，创建<code>/etc/rc.local</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/rc.local</span><br></pre></td></tr></table></figure></li><li><p>编辑<code>/etc/rc.local</code>文件，脚本的作用是开机后将文本”this just a test”写入<code>text.log</code>文件，为了方便查看，我把它放在开机目录下，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo &quot;this just a test&quot; &gt; /home/yangjiao/text.log</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/yyangjiao/Ubuntu18.04_img_host/raw/master/img3.png"></p></li><li><p>执行下述命令，更改一下权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x /etc/rc.local</span><br></pre></td></tr></table></figure></li><li><p>依次执行下述命令，启动服务并查看它的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start rc-local.service</span><br><span class="line">sudo systemctl status rc-local.service</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/yyangjiao/Ubuntu18.04_img_host/raw/master/img4.png"></p></li><li><p>reboot命令重启后，查看相应目录下是否增加了<code>text.log</code>文件</p><p><img src="https://gitee.com/yyangjiao/Ubuntu18.04_img_host/raw/master/img5.png"></p></li></ul><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>脚本确实能够开机自启动，但是无法执行hexo命令，后改用nginx实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在linux主机上使用hexo搭建博客后，需要实现在开机后自启动hexo服务的功能&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo-note</title>
    <link href="https://yyangjiao.github.io/2021/10/07/hexo-note/"/>
    <id>https://yyangjiao.github.io/2021/10/07/hexo-note/</id>
    <published>2021-10-06T16:10:47.000Z</published>
    <updated>2021-10-06T16:19:04.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>安装git，参考<a href="https://yyangjiao.gitee.io/2021/10/05/git-note/">git-note | yangjiao’s blog (gitee.io)</a></li><li>安装nodejs，参考<a href="https://yyangjiao.gitee.io/2021/10/06/nvm-note/">nvm-note | yangjiao’s blog (gitee.io)</a></li></ul><h2 id="搭建hexo本地环境"><a href="#搭建hexo本地环境" class="headerlink" title="搭建hexo本地环境"></a>搭建hexo本地环境</h2><ul><li><p>执行命令<code>npm install hexo -g </code>安装hexo</p></li><li><p>桌面创建myblog文件夹，进入该文件夹右键启动git bash</p></li><li><p>执行命令<code>hexo init</code>进行初始化，初始化后文件结构如下</p><p><img src="https://gitee.com/yyangjiao/hexo_note_img_host/raw/master/img1.png"></p></li><li><p>依次执行下述命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #清除记录 可简写为hexo cl</span><br><span class="line">hexo generate #生成静态网页 可简写为hexo g</span><br><span class="line">hexo server #启动服务 可简写为hexok s</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/yyangjiao/hexo_note_img_host/raw/master/img2.png"></p></li><li><p>访问 <a href="http://localhost:4000/">http://localhost:4000</a> 查看网页</p><p><img src="https://gitee.com/yyangjiao/hexo_note_img_host/raw/master/img3.png"></p></li></ul><h2 id="部署至gitee"><a href="#部署至gitee" class="headerlink" title="部署至gitee"></a>部署至gitee</h2><p>暂无</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装git，参考&lt;a href=&quot;https://yyangjiao.gitee.io/2021/10/05/g</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nvm-note</title>
    <link href="https://yyangjiao.github.io/2021/10/06/nvm-note/"/>
    <id>https://yyangjiao.github.io/2021/10/06/nvm-note/</id>
    <published>2021-10-06T05:09:40.000Z</published>
    <updated>2021-10-06T15:26:53.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h2><ul><li>使用<a href="https://yyangjiao.github.io/2021/10/05/nodejs-note/">nodejs-note | yangjiao’s blog (yyangjiao.github.io)</a>所述方法安装nodejs后执行<code>npm install</code>命令会遇到EACCES permissions errors，必须要在管理员身份下运行cmd或git才可以完成安装</li><li><a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">Resolving EACCES permissions errors when installing packages globally | npm Docs (npmjs.com)</a>官方给出两种解决方案：重装nodejs或改变npm的默认目录，但第二种方案不适用Windos系统</li><li><a href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm">Downloading and installing Node.js and npm | npm Docs (npmjs.com)</a>采用第一种方案时要注意：官方强烈建议使用Node版本管理器（如nvm）来安装nodejs，而不建议使用安装包来安装nodejs，因为node安装程序会将npm安装在具有本地权限的目录下，这将在你使用npm执行全局安装时导致权限错误</li><li>官方给出的Windos系统下的Node版本管理器有两种：nodist和nvm-windos，这里我选择的是nvm-windos</li></ul><h2 id="安装nvm-windos"><a href="#安装nvm-windos" class="headerlink" title="安装nvm-windos"></a>安装nvm-windos</h2><ul><li><p>访问<a href="https://github.com/coreybutler/nvm-windows/releases/tag/1.1.7">Release 1.1.7 - Maintenance Release · coreybutler/nvm-windows (github.com)</a></p></li><li><p>获取安装包</p><p><img src="https://gitee.com/yyangjiao/nvm_note_img_host/raw/master/img1.png"></p></li><li><p>选择nvm-windos安装目录</p><p><img src="https://gitee.com/yyangjiao/nvm_note_img_host/raw/master/img2.png"></p></li><li><p>选择nodejs安装目录</p><p><img src="https://gitee.com/yyangjiao/nvm_note_img_host/raw/master/img3.png"></p></li></ul><h2 id="使用nvm安装nodejs"><a href="#使用nvm安装nodejs" class="headerlink" title="使用nvm安装nodejs"></a>使用nvm安装nodejs</h2><ul><li><p>删除原nodejs安装目录和C:\Users\74615\.npmrc以及环境变量-系统变量中的NODE_PATH</p></li><li><p>查看nvm版本</p><p><img src="https://gitee.com/yyangjiao/nvm_note_img_host/raw/master/img4.png"></p></li><li><p>执行命令<code>nvm install nodejs版本号</code>安装对应版本的nodejs</p><p><img src="https://gitee.com/yyangjiao/nvm_note_img_host/raw/master/img5.png"></p></li><li><p>执行<code>nvm ls</code>查看已安装的nodejs版本，执行<code>nvm use nodejs版本号</code>启用该版本的nodejs</p><p><img src="https://gitee.com/yyangjiao/nvm_note_img_host/raw/master/img6.png"></p></li><li><p>这种方式安装nodejs不需要再后续配置nodejs</p></li><li><p>后续执行命令如<code>npm install hexo-cli -g</code>进行全局安装时不再需要管理员权限</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入原因&quot;&gt;&lt;a href=&quot;#引入原因&quot; class=&quot;headerlink&quot; title=&quot;引入原因&quot;&gt;&lt;/a&gt;引入原因&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&quot;https://yyangjiao.github.io/2021/10/05/nodejs</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nodejs-note</title>
    <link href="https://yyangjiao.github.io/2021/10/05/nodejs-note/"/>
    <id>https://yyangjiao.github.io/2021/10/05/nodejs-note/</id>
    <published>2021-10-05T13:59:57.000Z</published>
    <updated>2021-10-06T15:26:25.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ul><li><p>访问<a href="http://nodejs.cn/download/">下载 | Node.js 中文网 (nodejs.cn)</a></p></li><li><p>下载安装包</p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img1.png"></p></li><li><p>选择安装目录，其余默认</p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img2.png"></p></li><li><p>执行命令<code>node -v</code>和<code>npm -v</code>查看是否安装成功</p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img3.png"></p></li></ul><h2 id="配置npm"><a href="#配置npm" class="headerlink" title="配置npm"></a>配置npm</h2><ul><li><p>当执行<code>npm install express -g</code>等命令进行全局安装时，默认将模块安装在<code>C:\Users\用户名\AppData\Roaming</code>目录下的npm中，缓存cache也位于该目录下，占用C盘空间而且不方便管理</p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img4.png"></p></li><li><p>我们可以自己配置全局模块的安装目录，在nodejs的安装目录下新建两个文件夹</p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img5.png"></p></li><li><p>在nodejs安装目录下通过cmd执行下述两个命令</p><p><code>npm config set prefix &quot;D:\tool\nodejs\node_global&quot;</code></p><p><code>npm config set cache &quot;D:\tool\nodejs\node_cache&quot;</code></p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img6.png"></p></li><li><p>在环境变量-用户变量的Path中，将图示中npm的路径改为<code>D:\tool\nodejs\node_global</code></p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img7.png"></p></li><li><p>在环境变量-系统变量中新建系统变量<code>NODE_PATH</code></p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img8.png"></p></li><li><p><strong>管理员身份</strong>运行cmd进入nodejs安装目录，执行命令<code>npm install express -g</code>测试是否配置成功</p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img9.png"></p></li><li><p>express被安装在<code>D:\tool\nodejs\node_global\node_modules</code>，表明配置成功</p><p><img src="https://gitee.com/yyangjiao/nodejs_note_img_host/raw/master/img10.png"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nodejs&quot;&gt;&lt;a href=&quot;#安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;安装nodejs&quot;&gt;&lt;/a&gt;安装nodejs&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;访问&lt;a href=&quot;http://nodejs.cn/download/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>git-note</title>
    <link href="https://yyangjiao.github.io/2021/10/05/git-note/"/>
    <id>https://yyangjiao.github.io/2021/10/05/git-note/</id>
    <published>2021-10-05T08:43:21.000Z</published>
    <updated>2021-10-06T15:26:09.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><ul><li><p>访问<a href="https://git-scm.com/">Git (git-scm.com)</a></p></li><li><p>点击图示位置获取安装包</p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE1.png"></p></li><li><p>选择安装路径和编辑器，其余默认</p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE2.png"></p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE3.png"></p></li></ul><h2 id="git环境配置"><a href="#git环境配置" class="headerlink" title="git环境配置"></a>git环境配置</h2><ul><li><p>右键启动Git Bash</p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE4.png"></p></li><li><p>设置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yangjiao&quot; #用户名</span><br><span class="line">git config --global user.email hit_yangjiao@163.com #邮箱</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE5.png"></p></li></ul><h2 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h2><ul><li><p>打开git bash</p></li><li><p>执行命令<code>ssh-keygen -t rsa -C &quot;hit_yangjiao@163.com&quot;</code>生成公钥和私钥，提示是否设置密码，一般不予设置，直接回车即可，这样会在文件夹（<code>~/.ssh</code>）里生成私钥 id_rsa和公钥id_rsa.pub</p></li><li><p>可以通过执行命令<code>start ~/.ssh</code>打开存放私钥和公钥的文件夹</p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE6.png"></p></li><li><p>执行命令<code>cat ~/.ssh/id_rsa.pub</code>查看公钥</p></li></ul><h2 id="通过git向gitee仓库上传文件"><a href="#通过git向gitee仓库上传文件" class="headerlink" title="通过git向gitee仓库上传文件"></a>通过git向gitee仓库上传文件</h2><ul><li><p>复制仓库链接</p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE7.png"></p></li><li><p>打开git base，执行命令<code>git clone https://gitee.com/yyangjiao/git_note_img_host.git</code></p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE8.png"></p></li><li><p>将要上传gitee仓库的文件移动到该文件夹下（<code>git_note_img_host</code>）</p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE9.png"></p></li><li><p>执行命令<code>cd git_note_img_host/</code>进入该文件夹下</p></li><li><p>依次执行下述命令将文件上传到gitee仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;upload test&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE10.png"></p></li><li><p>查看gitee仓库是否更新</p><p><img src="https://gitee.com/yyangjiao/git_note_img_host/raw/master/%E5%9B%BE11.png"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装git&quot;&gt;&lt;a href=&quot;#安装git&quot; class=&quot;headerlink&quot; title=&quot;安装git&quot;&gt;&lt;/a&gt;安装git&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;访问&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git (git-scm.com</summary>
      
    
    
    
    
  </entry>
  
</feed>

<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>cpp-note | yangjiao's blog</title><meta name="author" content="yangjiao"><meta name="copyright" content="yangjiao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++基础指针1.指针数据类型所占的内存空间32位操作系统下，所有指针数据类型所占的内存空间都是4个字节； 64位操作系统下，所有指针数据类型所占的内存空间都是8个字节； 2.空指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意点：空指针指向的内存是不可以访问的（内存编号0~255的空间为系统占用内存，不允许用户访问） 1234int* p &#x3D; NULL;	&#x2F;&#x2F;指针变量p指向">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp-note">
<meta property="og:url" content="https://yyangjiao.github.io/2021/10/21/cpp-note/index.html">
<meta property="og:site_name" content="yangjiao&#39;s blog">
<meta property="og:description" content="C++基础指针1.指针数据类型所占的内存空间32位操作系统下，所有指针数据类型所占的内存空间都是4个字节； 64位操作系统下，所有指针数据类型所占的内存空间都是8个字节； 2.空指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意点：空指针指向的内存是不可以访问的（内存编号0~255的空间为系统占用内存，不允许用户访问） 1234int* p &#x3D; NULL;	&#x2F;&#x2F;指针变量p指向">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yyangjiao/illustration_host/raw/master/img7.jpg">
<meta property="article:published_time" content="2021-10-21T08:50:24.000Z">
<meta property="article:modified_time" content="2021-10-21T09:07:04.639Z">
<meta property="article:author" content="yangjiao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yyangjiao/illustration_host/raw/master/img7.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://yyangjiao.github.io/2021/10/21/cpp-note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cpp-note',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-21 17:07:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="yangjiao's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/yyangjiao/illustration_host/raw/master/img7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">yangjiao's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">cpp-note</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-21T08:50:24.000Z" title="发表于 2021-10-21 16:50:24">2021-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-21T09:07:04.639Z" title="更新于 2021-10-21 17:07:04">2021-10-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="cpp-note"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="1-指针数据类型所占的内存空间"><a href="#1-指针数据类型所占的内存空间" class="headerlink" title="1.指针数据类型所占的内存空间"></a>1.指针数据类型所占的内存空间</h3><p>32位操作系统下，所有指针数据类型所占的内存空间都是4个字节；</p>
<p>64位操作系统下，所有指针数据类型所占的内存空间都是8个字节；</p>
<h3 id="2-空指针"><a href="#2-空指针" class="headerlink" title="2.空指针"></a>2.空指针</h3><p>空指针：指针变量指向内存中编号为0的空间</p>
<p>用途：初始化指针变量</p>
<p>注意点：空指针指向的内存是不可以访问的（内存编号0~255的空间为系统占用内存，不允许用户访问）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;	<span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line">*p = <span class="number">100</span>;		<span class="comment">//报错</span></span><br><span class="line">cout &lt;&lt; *p;		<span class="comment">//报错</span></span><br><span class="line">cout &lt;&lt; p;		<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure>

<h3 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3.野指针"></a>3.野指针</h3><p>野指针：指针变量指向非法的内存空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="number">0x1100</span>;	<span class="comment">//p就是一个野指针</span></span><br><span class="line">cout &lt;&lt; *p;		<span class="comment">//异常：读取访问权限冲突</span></span><br></pre></td></tr></table></figure>

<p>总结：空指针和野指针指向的内存空间不是我们自己申请的，要避免使用它们</p>
<h3 id="4-const修饰指针"><a href="#4-const修饰指针" class="headerlink" title="4.const修饰指针"></a>4.const修饰指针</h3><p><strong>转载自：</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/CFrieman/article/details/79148232?utm_source=blogxgwz8">https://blog.csdn.net/CFrieman/article/details/79148232?utm_source=blogxgwz8</a></p>
<ul>
<li><p>const int *p 指向常量的指针 </p>
<p>就是所谓的“指向常量的指针”。这里注意，所谓“指向常量”只是这个指针的“一厢情愿”，只是一种效果上的等价。事实上，const int *p=&a;a既可以是常量(const int a=10;)又可以是变量(int a=10;)，但p一厢情愿地认为它所指的就是一个常量，所以它不允许通过自己来修改所指，这就造成一种效果上的等价——从p的角度看，它所指的“的确”是常量。所以，对“指向常量的指针”的最佳理解应为：我们不能通过该指针修改它所指向的东西（常量或者变量）。</p>
<p>注意，const int *p=&a;只是说不能通过p来修改a，如果a本身不是const的，通过其它方式修改a自然是可以的（例如直接++a）。</p>
<p>另外一点，由于p本身只是一个普通的指针，所以允许在声明时不初始化。但需要注意的是，我们只是说可以，但并不提倡这样做。在任何时候都不应该让指针无所指，如果在声明一个指针时还不知道让它指向谁，就先将其初始化为nullptr或NULL（nullptr是C++11新特性，用它比用NULL更安全些，这里不详细介绍）。</p>
<p>注意：int const* p = &a; 这种写法也是对的</p>
</li>
<li><p>int* const p 指针常量</p>
<p>就是所谓的“本身是常量的指针”。p本身（也就是p的指向）不能修改但可以通过p修改其所指向的变量值，所以p只能指向变量，不可以指向常量。这里再说一下p的初始化：</p>
<p>由于p本身是const的，所以在编译的时候必须知道p的值（即p所指向的东西的地址），所以在声明p的同时必须初始化p。但要注意，对于 int* const p=&amp;a，我们只要求a的地址是确定的，但a的值可以不确定，就是说a可以声明但不初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;				<span class="comment">//声明但未初始化a</span></span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> p;		<span class="comment">//错误：声明p的同时没有初始化p</span></span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;	<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外注意，用nullptr或NULL初始化int* const p没有问题，因为nullptr和NULL都代表有效地址。</p>
</li>
<li><p>const int* const p</p>
<p>就是所谓的“所指和本身都是常量的指针”。它的语法特性就是前两者的结合，这里不再赘述。</p>
</li>
</ul>
<h3 id="5-指针和数组"><a href="#5-指针和数组" class="headerlink" title="5.指针和数组"></a>5.指针和数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> arr[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">double</span>* p = arr;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;	<span class="comment">//p此时指向arr[0] 故打印出arr[0]的地址</span></span><br><span class="line">	p++;				<span class="comment">//我理解的是：让p指向arr[0]的同时p+1指向了arr[1]，p = p+1后，p就指向了arr[1],所以打印的地址值相差sizeof(double)</span></span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;	<span class="comment">//p此时指向arr[1] 故打印出arr[1]的地址</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************结果**************************</span></span><br><span class="line"><span class="number">008F</span>F874</span><br><span class="line"><span class="number">008F</span>F87C</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="6-指针和函数"><a href="#6-指针和函数" class="headerlink" title="6.指针和函数"></a>6.指针和函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *num1;</span><br><span class="line">	*num1 = *num2;</span><br><span class="line">	*num2 = temp;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************结果**************************</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="1-结构体定义和使用"><a href="#1-结构体定义和使用" class="headerlink" title="1.结构体定义和使用"></a>1.结构体定义和使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;ps3;<span class="comment">//结构体使用3(定义结构体的同时创建结构体变量，不建议使用)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//结构体使用1</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">ps1</span>;</span></span><br><span class="line">	ps1.name = <span class="string">&quot;LiHua&quot;</span>;</span><br><span class="line">	ps1.age = <span class="number">19</span>;</span><br><span class="line">	<span class="comment">//结构体使用2</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">ps2</span> =</span> &#123; <span class="string">&quot;YangJiao&quot;</span>,<span class="number">20</span> &#125;;</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="comment">//struct Person ps2&#123; &quot;YangJiao&quot;,20 &#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：创建结构体变量时，struct关键字可以省略</p>
<h3 id="2-结构体数组"><a href="#2-结构体数组" class="headerlink" title="2.结构体数组"></a>2.结构体数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//结构体数组</span></span><br><span class="line">	Person psArr[<span class="number">3</span>] = &#123; &#123;<span class="string">&quot;LiHua&quot;</span>,<span class="number">19</span>&#125;,&#123;<span class="string">&quot;YangJiao&quot;</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&quot;PeiYun&quot;</span>,<span class="number">21</span>&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-结构体指针"><a href="#3-结构体指针" class="headerlink" title="3.结构体指针"></a>3.结构体指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person ps = &#123; <span class="string">&quot;LiHua&quot;</span>,<span class="number">19</span> &#125;;</span><br><span class="line">	<span class="comment">//结构体指针</span></span><br><span class="line">	Person* psPtr = &amp;ps;</span><br><span class="line">	cout &lt;&lt; psPtr-&gt;name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; psPtr-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************结果**************************</span></span><br><span class="line">LiHua</span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure>

<h3 id="4-结构体嵌套结构体"><a href="#4-结构体嵌套结构体" class="headerlink" title="4.结构体嵌套结构体"></a>4.结构体嵌套结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> &#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	string subject;</span><br><span class="line">	Student stu;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Teacher tc = &#123; <span class="string">&quot;WangMing&quot;</span>,<span class="number">37</span>,<span class="string">&quot;Math&quot;</span>,&#123;<span class="string">&quot;LiHua&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">	<span class="comment">//或</span></span><br><span class="line">	<span class="comment">//Teacher tc&#123; &quot;WangMing&quot;,37,&quot;Math&quot;,&#123;&quot;LiHua&quot;,20&#125; &#125;;</span></span><br><span class="line">	cout &lt;&lt; tc.stu.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-结构体作函数参数"><a href="#5-结构体作函数参数" class="headerlink" title="5.结构体作函数参数"></a>5.结构体作函数参数</h3><p>作用：结构体作为参数向函数中传递</p>
<p>传递方式：值传递和地址传递</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*********************值传递*********************</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person _ps)</span> </span>&#123;</span><br><span class="line">	_ps.age = <span class="number">21</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;name_printPerson: &quot;</span> &lt;&lt; _ps.name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;age_printPerson: &quot;</span> &lt;&lt; _ps.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person ps = &#123; <span class="string">&quot;LiHua&quot;</span>,<span class="number">20</span> &#125;;</span><br><span class="line">	<span class="built_in">printPerson</span>(ps);</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;age_main: &quot;</span>&lt;&lt; ps.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*********************结果*********************</span></span><br><span class="line">name_printPerson: LiHua</span><br><span class="line">age_printPerson: <span class="number">21</span></span><br><span class="line">age_main: <span class="number">20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//********************地址传递********************</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person* _ps)</span> </span>&#123;</span><br><span class="line">	_ps-&gt;age = <span class="number">21</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;name_printPerson: &quot;</span> &lt;&lt; _ps-&gt;name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;age_printPerson: &quot;</span> &lt;&lt; _ps-&gt;age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person ps = &#123; <span class="string">&quot;LiHua&quot;</span>,<span class="number">20</span> &#125;;</span><br><span class="line">	<span class="built_in">printPerson</span>(&amp;ps);</span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;age_main: &quot;</span>&lt;&lt; ps.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*********************结果*********************</span></span><br><span class="line">name_printPerson: LiHua</span><br><span class="line">age_printPerson: <span class="number">21</span></span><br><span class="line">age_main: <span class="number">21</span></span><br></pre></td></tr></table></figure>

<h3 id="6-结构体中const的使用场景"><a href="#6-结构体中const的使用场景" class="headerlink" title="6.结构体中const的使用场景"></a>6.结构体中const的使用场景</h3><p>作用：用const来防止误操作</p>
<p>当我们的函数只要求读取，而不修改传入的参数时，可以使用值传递，但是会复制新的副本，占用内存空间，地址传递可以减少内存空间的浪费，但是可能由于误操作在函数内部将参数修改掉，为了避免这种误操作，我们就需要使用const</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(<span class="keyword">const</span> Person* _ps)</span> </span>&#123;<span class="comment">//这是一个常量指针</span></span><br><span class="line">    <span class="comment">//这个函数的目的功能就是只读取，而不修改传入的参数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; _ps-&gt;name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;age: &quot;</span> &lt;&lt; _ps-&gt;age &lt;&lt; endl;</span><br><span class="line">	_ps-&gt;age = <span class="number">-1</span>;	<span class="comment">//假如不小心加入这一误操作，编译器就会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person ps = &#123; <span class="string">&quot;LiHua&quot;</span>,<span class="number">20</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-核心"><a href="#C-核心" class="headerlink" title="C++核心"></a>C++核心</h1><h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序在执行时，将内存大方向上划分为4个区域</p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理</li>
<li>全局区：存放全局变量、静态变量和部分常量</li>
<li>栈区：由编译器自动分配释放，存放函数的形参和局部变量</li>
<li>堆区：由程序员分配和释放，若程序员没有进行释放操作，程序结束时由操作系统回收</li>
</ul>
<p>内存分区的意义：不同区域存放不同类型的数据，赋予不同的生命周期，方便更加灵活的进行编程</p>
<h3 id="1-代码区和全局区"><a href="#1-代码区和全局区" class="headerlink" title="1.代码区和全局区"></a>1.代码区和全局区</h3><p>程序运行前:</p>
<p>在程序编译后，生成了exe可执行文件，在还未执行该exe文件前，内存中就分好了两个区域</p>
<ul>
<li><p>代码区：</p>
<ul>
<li>存放CPU执行的机器指令</li>
<li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可（简单来说就是我们连续多次执行该exe文件，执行的都是这一份代码）</li>
<li>代码区是<strong>只读</strong>的，目的是防止意外地修改了程序的指令</li>
</ul>
</li>
<li><p>全局区：</p>
<ul>
<li><p>存放全局变量和静态变量</p>
</li>
<li><p>全局区中包含常量区，故字符串常量和全局常量也存放在这里（局部常量不在常量区，而与局部变量在一个区域）</p>
</li>
<li><p>该区域的数据在程序结束后由操作系统释放</p>
</li>
<li><p>```c++<br>#include<iostream><br>using namespace std;</p>
<p>//全局变量<br>int g_a = 0;<br>int g_b = 0;<br>//全局常量<br>const int G_A = 0;<br>const int G_B = 0;<br>int main() {</p>
<pre><code>//局部变量
int a = 0;
int b = 0;
//静态变量
static int s_a = 0;
static int s_b = 0;
//局部常量
const int A = 0;
const int B = 0;
cout &lt;&lt; &quot;局部变量a的地址：&quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;
cout &lt;&lt; &quot;局部变量b的地址：&quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;
cout &lt;&lt; &quot;全局变量g_a的地址：&quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl;
cout &lt;&lt; &quot;全局变量g_b的地址：&quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl;
cout &lt;&lt; &quot;静态变量s_a的地址：&quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;
cout &lt;&lt; &quot;静态变量s_b的地址：&quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;
cout &lt;&lt; &quot;字符串常量\&quot;hello world\&quot;的地址&quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;
cout &lt;&lt; &quot;全局常量G_A的地址：&quot; &lt;&lt; (int)&amp;G_A &lt;&lt; endl;
cout &lt;&lt; &quot;全局常量G_B的地址：&quot; &lt;&lt; (int)&amp;G_B &lt;&lt; endl;
cout &lt;&lt; &quot;局部常量A的地址&quot; &lt;&lt; (int)&amp;A &lt;&lt; endl;
cout &lt;&lt; &quot;局部常量B的地址&quot; &lt;&lt; (int)&amp;B &lt;&lt; endl;
</code></pre>
<p>}<br>//<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>结果</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><br>局部变量a的地址：7339264<br>局部变量b的地址：7339252<br>全局变量g_a的地址：8504428<br>全局变量g_b的地址：8504432<br>静态变量s_a的地址：8504436<br>静态变量s_b的地址：8504440<br>字符串常量”hello world”的地址8494096<br>全局常量G_A的地址：8494376<br>全局常量G_B的地址：8494380<br>局部常量A的地址7339240<br>局部常量B的地址7339228</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2.栈区和堆区</span><br><span class="line"></span><br><span class="line">程序运行后：</span><br><span class="line"></span><br><span class="line">- 栈区：</span><br><span class="line"></span><br><span class="line">  - 由编译器自动分配和释放内存，存放的是函数的形参和局部变量（还有局部常量）</span><br><span class="line"></span><br><span class="line">  - **注意事项：**不要返回局部变量的地址</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    int* func() &#123;</span><br><span class="line">    	int a = 10;	//编译器自动为局部变量a分配了一块内存空间来存放数据10，当fun()函数执行完后，这块内存空间又会被自动释放，这块空间中存放的数据就不在是10了</span><br><span class="line">    	cout &lt;&lt; &quot;为a分配的内存空间地址: &quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    	return &amp;a;</span><br><span class="line">    &#125;</span><br><span class="line">    int main() &#123;</span><br><span class="line">    	int* p = func();	//p指向func()中为a分配的内存空间</span><br><span class="line">    	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    //*********************结果*********************</span><br><span class="line">    为a分配的内存空间地址: 0073FBE4</span><br><span class="line">    0073FBE4	//p是指向这块空间</span><br><span class="line">    2067712528	//但是这块空间中存放的值不再是10了</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>堆区：</p>
<ul>
<li><p>由程序员分配释放，若程序员没有进行释放操作，程序结束时由操作系统回收</p>
</li>
<li><p>在C++中主要利用new在堆区开辟内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//使用new关键字在堆区为数据分配空间</span></span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);	<span class="comment">//new返回的是地址，所以用一个指针接收</span></span><br><span class="line">	<span class="keyword">return</span> p;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在堆区为数据分配空间</span></span><br><span class="line">	<span class="keyword">int</span>* ptr = <span class="built_in">func</span>();</span><br><span class="line">	cout &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-new操作符"><a href="#3-new操作符" class="headerlink" title="3.new操作符"></a>3.new操作符</h3><ul>
<li><p>C++中利用new操作符在堆区为数据开辟空间</p>
</li>
<li><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放要使用delete操作符</p>
</li>
<li><p>使用new在堆区为数据开辟空间，返回的是一个地址，需要用该数据对应类型的指针接收</p>
</li>
<li><p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//基本数据类型</span></span><br><span class="line">	<span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>); <span class="comment">//数据值为10</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="comment">//数组</span></span><br><span class="line">	<span class="keyword">int</span>* pArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//数组有10个元素</span></span><br><span class="line">	<span class="keyword">delete</span>[] pArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="1-引用的基本使用"><a href="#1-引用的基本使用" class="headerlink" title="1.引用的基本使用"></a>1.引用的基本使用</h3><ul>
<li><p>作用：给变量起个别名</p>
</li>
<li><p>语法：数据类型 &amp;别名 =  原名;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> LiHua = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; YangJiao = LiHua;</span><br><span class="line">	cout &lt;&lt; LiHua &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; YangJiao &lt;&lt; endl;</span><br><span class="line">	YangJiao = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; LiHua &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; YangJiao &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-引用注意事项"><a href="#2-引用注意事项" class="headerlink" title="2.引用注意事项"></a>2.引用注意事项</h3><ul>
<li><p>引用必须初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;YangJiao;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用在初始化之后，不可以改变</p>
</li>
</ul>
<h3 id="3-引用作函数参数"><a href="#3-引用作函数参数" class="headerlink" title="3.引用作函数参数"></a>3.引用作函数参数</h3><ul>
<li><p>作用：函数传参时，可以利用引用的技术，使得形参修饰实参（就是可以通过在函数中修改形参来修改实参）</p>
</li>
<li><p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; num1, <span class="keyword">int</span>&amp; num2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*********************结果*********************</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-引用作函数返回值"><a href="#4-引用作函数返回值" class="headerlink" title="4.引用作函数返回值"></a>4.引用作函数返回值</h3><ul>
<li><p>注意：不要返回局部变量的引用</p>
</li>
<li><p>用法：可将返回值为引用的函数作为左值使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;	<span class="comment">//全局区的静态变量</span></span><br><span class="line">	<span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>&amp; ref = <span class="built_in">func</span>();	<span class="comment">//func()返回的是a的引用</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>() = <span class="number">20</span>;	<span class="comment">//函数作左值</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*********************结果*********************</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-引用的本质"><a href="#5-引用的本质" class="headerlink" title="5.引用的本质"></a>5.引用的本质</h3><ul>
<li><p>本质：引用的在C++内部的实现是一个指针常量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; ref = a;	<span class="comment">//自动转换为int* const ref = &amp;a; 指针常量不可以修改指向，这就说明为什么引用不可以更改 同样因为指针常量必须初始化，这点就说明了为什么引用必须初始化</span></span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//编译器发现ref是引用，自动转换为*ref = 20;</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>C++推荐使用引用技术，本质上是指针常量，但是语法上更加简单方便</p>
</li>
</ul>
<h3 id="6-常量引用"><a href="#6-常量引用" class="headerlink" title="6.常量引用"></a>6.常量引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//int&amp; ref = 10;	//错误：非常量引用的初始值必须为左值</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;<span class="comment">//常量引用</span></span><br><span class="line">	<span class="comment">//正确：const修饰后，编译器自动将代码转换为int temp = 10; int&amp; ref = temp;</span></span><br><span class="line">	<span class="comment">//ref = 20;	//常量引用不可以修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用：常量引用主要用来修饰形参，防止误操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ref = 10;	//若存在这样一条误操作，编译器会报错</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">print</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>引用本质上是指针常量，所以常量引用本质上是指向常量的指针常量，不允许修改指向，但“指向常量”是它“一厢情愿”的，它自己认为自己指向的是常量，所以“不敢”修改指向对象的值，但实际上它指向的也可能是变量，虽然不能通过这个引用修改其值，但是可以通过直接修改这个变量来修改其值。（跳转至C++基础-指针-4.const修饰的指针）</p>
</li>
</ul>
<h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="1-函数默认值"><a href="#1-函数默认值" class="headerlink" title="1.函数默认值"></a>1.函数默认值</h3><ul>
<li>在C++中，函数形参列表中的形参是可以有默认值的</li>
<li>带默认值的参数只能在形参列表最右侧</li>
<li>函数声明和函数实现中只能有一个带默认值</li>
</ul>
<h3 id="2-函数占位参数"><a href="#2-函数占位参数" class="headerlink" title="2.函数占位参数"></a>2.函数占位参数</h3><ul>
<li><p>C++中函数的形参列表里可以有占位参数，用来作占位，调用函数时必须填补该位置</p>
</li>
<li><p>占位参数也可以有默认值</p>
</li>
<li><p>```c++<br>#include<iostream><br>using namespace std;<br>void fun(int num1, int, int num2, int = 10) {//第2个和第4个参数都是占位参数，而且第4个参数有默认值</p>
<pre><code>cout &lt;&lt; &quot;函数的占位参数&quot; &lt;&lt; endl;
</code></pre>
<p>}<br>int main() {</p>
<pre><code>fun(1, 2, 3);
</code></pre>
<p>}<br>//<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>结果</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><br>函数的占位参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.函数重载</span><br><span class="line"></span><br><span class="line">- 作用：函数名可以相同，提高复用性</span><br><span class="line"></span><br><span class="line">- 函数重载的条件：</span><br><span class="line"></span><br><span class="line">  - 同一作用域下（目前我们的函数都是全局函数，满足这一条件）</span><br><span class="line">  - 函数名称相同</span><br><span class="line">  - 函数的形参类型或个数不同</span><br><span class="line">  - 注意：返回值不可以做为重载条件</span><br><span class="line"></span><br><span class="line">- 注意事项：</span><br><span class="line"></span><br><span class="line">  - 引用作重载条件</span><br><span class="line"></span><br><span class="line">    ```c++</span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    void func(int&amp; ref) &#123;</span><br><span class="line">    	cout &lt;&lt; &quot;调用的是func(int&amp; ref)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void func(const int&amp; ref) &#123;</span><br><span class="line">    	cout &lt;&lt; &quot;调用的是func(const int&amp; ref)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    int main() &#123;</span><br><span class="line">    	int a = 10;</span><br><span class="line">    	const int b = 10;</span><br><span class="line">    	func(a);</span><br><span class="line">    	func(10);</span><br><span class="line">    	func(b);</span><br><span class="line">    &#125;</span><br><span class="line">    //*********************结果*********************</span><br><span class="line">    调用的是func(int&amp; ref)</span><br><span class="line">    调用的是func(const int&amp; ref)</span><br><span class="line">    调用的是func(const int&amp; ref)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当函数重载遇到默认参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func(int a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func(int a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);	<span class="comment">//报错:有多个重载函数与参数列表匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特性：封装、继承、多态</p>
<h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><ul>
<li>封装的意义：<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>对属性和行为加以访问权限（public公共权限、protected保护权限、private私有权限）</li>
</ul>
</li>
<li>struct和class的区别：<ul>
<li>struct默认访问权限是public</li>
<li>class默认访问权限是private</li>
<li>注意：C++中没有default访问权限</li>
</ul>
</li>
<li>成员属性私有化<ul>
<li>优点：<ul>
<li>将所有成员属性私有化，可以由我们自己控制其读写权限（设置相应的权限为public的set和get函数，通过这些函数来读写成员属性）</li>
<li>对于写权限，我们可以通过对应的set函数，在函数内检验数据的有效性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-对象的初始化和清理"><a href="#2-对象的初始化和清理" class="headerlink" title="2.对象的初始化和清理"></a>2.对象的初始化和清理</h3><ul>
<li><p>对象的初始化和清理是两个非常重要的安全问题：</p>
<ul>
<li>一个对象或者变量没有初始状态，对其使用的后果是未知的</li>
<li>使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</li>
</ul>
</li>
<li><p>构造函数和析构函数：</p>
<p>C++利用构造函数和析构函数解决上述的问题，这两个函数会被编译器自动调用来完成对象的初始化和清理，对象的初始化和清理是编译器要求我们做的事情，如果我们不提供任何构造函数和析构函数，编译器会提供默认的构造函数和析构函数（默认提供的构造函数和析构函数都是空实现，即函数体为空）</p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用</li>
<li>析构函数：主要作用在于在对象销毁前由编译器自动调用，执行一些清理工作</li>
</ul>
</li>
</ul>
<h4 id="2-1构造函数"><a href="#2-1构造函数" class="headerlink" title="2.1构造函数"></a>2.1构造函数</h4><ul>
<li><p>构造函数的分类</p>
<ul>
<li>按参数分为：有参构造函数和无参构造函数</li>
<li>按类型分为：普通构造函数和拷贝构造函数</li>
</ul>
</li>
<li><p>创建对象的3种方式：括号法、显示法、隐式转换法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(string _name, <span class="keyword">int</span> _age) &#123;</span><br><span class="line">		name = _name;</span><br><span class="line">		age = _age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">		name = p.name;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string _name)</span> </span>&#123;</span><br><span class="line">		name = _name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> _age)</span> </span>&#123;</span><br><span class="line">		age = _age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//******************************1.括号法******************************</span></span><br><span class="line">	</span><br><span class="line">	Person p0;				<span class="comment">//调用无参构造函数创建对象</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;LiHua&quot;</span>,<span class="number">19</span>)</span></span>;	<span class="comment">//调用有参构造函数创建对象</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;			<span class="comment">//调用拷贝构造函数创建对象</span></span><br><span class="line">	<span class="comment">//注意点：</span></span><br><span class="line">		<span class="comment">//括号法调用无参构造函数创建对象时，不要加括号</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">()</span></span>; <span class="comment">//编译器会把该语句认为是函数的声明</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//******************************2.显示法（联想Java）********************</span></span><br><span class="line"></span><br><span class="line">	Person p4 = <span class="built_in">Person</span>();	<span class="comment">//调用无参构造函数创建对象</span></span><br><span class="line">	Person p5 = <span class="built_in">Person</span>(<span class="string">&quot;YangJiao&quot;</span>, <span class="number">20</span>);	<span class="comment">//调用有参构造函数创建对象</span></span><br><span class="line">	Person p6 = <span class="built_in">Person</span>(p5);	<span class="comment">//调用拷贝构造函数创建对象</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="string">&quot;WangJie&quot;</span>, <span class="number">21</span>);	<span class="comment">//调用有参构造函数创建的匿名对象</span></span><br><span class="line">	<span class="comment">//匿名对象注意点1：执行完当前行后，匿名对象就会被系统回收</span></span><br><span class="line">	<span class="comment">//匿名对象注意点2：不要利用拷贝构造函数创建匿名对象</span></span><br><span class="line">		<span class="comment">//Person(p6); //报错：原因是编译器认为Person(p6) === Person p6;造成重定义</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//******************************3.隐式转换法****************************</span></span><br><span class="line">    Person p7 = &#123; <span class="string">&quot;WangMing&quot;</span>,<span class="number">20</span> &#125;;<span class="comment">//当类只有一个成员变量时可以不加大括号 </span></span><br><span class="line">    <span class="comment">//等同于 Person p7(&quot;WangMing&quot;,20);</span></span><br><span class="line">    Person p9 = p8;	<span class="comment">//等同于Person p9(p8);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//***********************************结果***********************************</span></span><br><span class="line">调用Person类的无参构造函数</span><br><span class="line">调用Person类的有参构造函数</span><br><span class="line">调用Person类的拷贝构造函数</span><br><span class="line">调用Person类的无参构造函数</span><br><span class="line">调用Person类的有参构造函数</span><br><span class="line">调用Person类的拷贝构造函数</span><br><span class="line">调用Person类的有参构造函数</span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的有参构造函数</span><br><span class="line">调用Person类的拷贝构造函数</span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的析构函数</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2拷贝构造函数的调用时机"><a href="#2-2拷贝构造函数的调用时机" class="headerlink" title="2.2拷贝构造函数的调用时机"></a>2.2拷贝构造函数的调用时机</h4><p>C++种拷贝构造函数的调用时机通常有3种：</p>
<ul>
<li><p>使用一个已经存在的对象来创建并初始化一个新的对象时</p>
</li>
<li><p>函数发生值传递时会调用拷贝构造函数（因为值传递的本质是复制一份副本）</p>
</li>
<li><p>以值方式返回局部对象时（本质上也是复制了一份副本）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上一份代码基础上</span></span><br><span class="line"><span class="function">Person <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	cout &lt;&lt; (<span class="keyword">int</span>)&amp;p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person ps = <span class="built_in">func1</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="keyword">int</span>)&amp;ps &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">调用Person类的无参构造函数	<span class="comment">//Person p;</span></span><br><span class="line"><span class="number">9436392</span>					<span class="comment">//p的地址</span></span><br><span class="line">调用Person类的拷贝构造函数	<span class="comment">//return p</span></span><br><span class="line">调用Person类的析构函数		<span class="comment">//清理p</span></span><br><span class="line"><span class="number">9436668</span>						<span class="comment">//ps的地址</span></span><br><span class="line">调用Person类的析构函数		<span class="comment">//清理ps</span></span><br><span class="line"><span class="comment">//我的疑问：语句Person ps = func1(); 为什么不发生拷贝构造？</span></span><br><span class="line"><span class="comment">/*已解决：</span></span><br><span class="line"><span class="comment">func1()中完成的工作是：</span></span><br><span class="line"><span class="comment">	首先创建p对象，然后打印了这个对象的地址;</span></span><br><span class="line"><span class="comment">	然后通过拷贝构造函数把p拷贝到保存返回值的外部存储部件ps中；</span></span><br><span class="line"><span class="comment">    最后，p对象在func1()函数结束时被销毁（调用p的析构函数）*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3构造函数调用规则"><a href="#2-3构造函数调用规则" class="headerlink" title="2.3构造函数调用规则"></a>2.3构造函数调用规则</h4><p>当我们没有编写任何构造函数和析构函数时，C++编译器至少给类添加3个函数</p>
<ul>
<li>默认构造函数（无参，函数体为空）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝构造函数（对属性值进行拷贝）</li>
</ul>
<p>默认构造函数的提供规则：</p>
<ul>
<li>如果用户定义了有参构造函数，C++不会再提供默认构造函数，但是仍会提供默认拷贝构造函数</li>
<li>如果用户定义了拷贝构造函数，C++不会再提供任何默认的构造函数</li>
</ul>
<h4 id="2-4深拷贝与浅拷贝"><a href="#2-4深拷贝与浅拷贝" class="headerlink" title="2.4深拷贝与浅拷贝"></a>2.4深拷贝与浅拷贝</h4><ul>
<li><p>浅拷贝：简单的赋值拷贝操作</p>
</li>
<li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
</li>
<li><p>浅拷贝带来的问题：可能导致堆区内存的重复释放，此外还有改一二变的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> *age;</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(string _name, <span class="keyword">int</span> _age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		name = _name;</span><br><span class="line">		age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(_age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;<span class="comment">//默认拷贝构造函数就是这种浅拷贝形式</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		name = p.name;</span><br><span class="line">		age = p.age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> age;</span><br><span class="line">			age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p0</span><span class="params">(<span class="string">&quot;LiHua&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(p0)</span></span>;</span><br><span class="line">	*p1.age = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; *p0.age &lt;&lt; endl;	<span class="comment">//输出10</span></span><br><span class="line">	cout &lt;&lt; *p1.age &lt;&lt; endl;	<span class="comment">//同样也是输出10 这就是改一二变问题</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解释：</span></span><br><span class="line">代码报错，因为p0.age和p1.age指向同一块堆区内存空间，<span class="built_in">func</span>()函数执行结束后，依次调用了p1和p0的析构函数，对这块堆区内存空间重复释放（不允许重复释放同一块内存空间）；这里还涉及一个知识点，栈区的特点是是先进后出，我们先创建p0则后销毁p0</span><br></pre></td></tr></table></figure></li>
<li><p>深拷贝的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;<span class="comment">//这是我们自己实现的深拷贝</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用Person类的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    name = p.name;</span><br><span class="line">    age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p0</span><span class="params">(<span class="string">&quot;LiHua&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(p0)</span></span>;</span><br><span class="line">	*p1.age = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; *p0.age &lt;&lt; endl;	<span class="comment">//输出19</span></span><br><span class="line">	cout &lt;&lt; *p1.age &lt;&lt; endl;	<span class="comment">//输出10 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-5初始化列表"><a href="#2-5初始化列表" class="headerlink" title="2.5初始化列表"></a>2.5初始化列表</h4><ul>
<li><p>作用：C++为构造函数提供了初始化列表语法，用来初始化属性（推荐使用该方法）</p>
</li>
<li><p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>():<span class="built_in">name</span>(<span class="string">&quot;&quot;</span>),<span class="built_in">age</span>(<span class="number">0</span>) &#123;<span class="comment">//注意C++中不能把NULL赋值给对象(string实质上是一个class类)（不同于Java）</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(string _name, <span class="keyword">int</span> _age):<span class="built_in">name</span>(_name),<span class="built_in">age</span>(_age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//传统实现同样功能的做法（实际是为属性赋值而不是初始化属性）（效率上相对低）</span></span><br><span class="line">		<span class="comment">/*name = _name;</span></span><br><span class="line"><span class="comment">		age = _age;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用Person类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p0;</span><br><span class="line">	cout &lt;&lt; p0.name &lt;&lt; endl;	</span><br><span class="line">	cout &lt;&lt; p0.age &lt;&lt; endl;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;LiHua&quot;</span>,<span class="number">19</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; p1.name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">调用Person类的无参构造函数</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line">调用Person类的有参构造函数</span><br><span class="line">LiHua</span><br><span class="line"><span class="number">19</span></span><br><span class="line">调用Person类的析构函数</span><br><span class="line">调用Person类的析构函数</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-6类对象作为类的成员属性"><a href="#2-6类对象作为类的成员属性" class="headerlink" title="2.6类对象作为类的成员属性"></a>2.6类对象作为类的成员属性</h4><ul>
<li><p>构造和析构的顺序问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">B</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">A的构造函数</span><br><span class="line">B的构造函数</span><br><span class="line">B的析构函数</span><br><span class="line">A的析构函数</span><br></pre></td></tr></table></figure>
<h4 id="2-7静态成员"><a href="#2-7静态成员" class="headerlink" title="2.7静态成员"></a>2.7静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员包括：</p>
<ul>
<li><p>静态成员变量（属性）</p>
<ul>
<li><p>所有该类的对象共享同一份数据</p>
</li>
<li><p>在编译阶段分配内存（全局区）</p>
</li>
<li><p>必须类内声明，类外定义（若某行代码使得其变量获得内存，则称为定义）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> hasID; <span class="comment">//类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> Student::hasID = <span class="literal">true</span>;	<span class="comment">//类外定义，至于赋不赋予初值都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Student stu;</span><br><span class="line">	cout &lt;&lt; stu.hasID &lt;&lt; endl;	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; Student::hasID &lt;&lt; endl;<span class="comment">//通过类名访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>静态成员函数</p>
<ul>
<li>所有该类的对象共享同一份函数（实际上，即便是非静态的成员函数也是所有的该类对象共享同一份，不过非静态成员函数可以通过this指针区别是哪个对象在调用自己，而静态成员函数中没有隐含this指针）</li>
<li>静态成员函数只能访问静态成员变量（因为静态成员函数中没有this指针）</li>
<li>静态成员函数既可以在类内声明并定义，也可以类内声明，类外定义</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-C-对象模型"><a href="#3-C-对象模型" class="headerlink" title="3.C++对象模型"></a>3.C++对象模型</h3><ul>
<li><p>成员变量与成员函数分开存储</p>
<p>在C++中，对象的成员变量和成员函数是分开存储的，只有非静态成员变量才存储在对象上，其他的都不存储在对象上</p>
</li>
<li><p>再补充一个知识点：空类对象所占的内存空间</p>
<p>当一个类A中没有声明任何成员变量和成员函数时，sizeof(A) = 1。编译器不允许一个类占用的内存空间大小为0，会为它分配1个字节的内存，若不这样做，那么两个类A的实例在内存中将会无法区分。为空类对象分配1字节的内存空间，这样就使得空类的这两个实例得以在内存中占有独一无二的地址。</p>
</li>
</ul>
<h3 id="4-this指针"><a href="#4-this指针" class="headerlink" title="4.this指针"></a>4.this指针</h3><h4 id="4-1this指针概念"><a href="#4-1this指针概念" class="headerlink" title="4.1this指针概念"></a>4.1this指针概念</h4><p>所有的同类对象公用相同一份非静态成员函数的代码，问题是：这块代码本身是如何区分是哪个对象在调用自己的呢？</p>
<p>C++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象。this指针是隐含在每一个非静态成员函数中的一种指针（当我们调用非静态成员函数时，调用对象的地址会被隐式地传给this指针），this指针不需要定义，直接使用即可。（this指针是一个指针常量，不能修改指向，这点在后面理解const修饰成员函数时会用到）</p>
<ul>
<li>用途：<ul>
<li>当形参和成员属性同名时，可用this指针加以区分</li>
<li>在类的非静态成员函数中要想返回对象本身，可使用return *this;（这里还要注意区分返回值和返回引用两种方式）</li>
</ul>
</li>
</ul>
<h4 id="4-2空指针访问成员函数"><a href="#4-2空指针访问成员函数" class="headerlink" title="4.2空指针访问成员函数"></a>4.2空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是要注意有没有使用this指针，如果用到this指针，需要加以判断来保证代码的健壮性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showNameAndAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; name &lt;&lt; endl;<span class="comment">//默认转换成this-&gt;name</span></span><br><span class="line">		cout &lt;&lt; age &lt;&lt; endl;<span class="comment">//同理 this-&gt;age	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Student* stu = <span class="literal">NULL</span>;</span><br><span class="line">	stu-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">	<span class="comment">//stu-&gt;showNameAndAge(); 报错，原因是用到了this指针，当前的this是NULL</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3const修饰成员函数"><a href="#4-3const修饰成员函数" class="headerlink" title="4.3const修饰成员函数"></a>4.3const修饰成员函数</h4><p>常函数：</p>
<ul>
<li>成员函数后加const后被称为常函数</li>
<li>常函数内部不可以修改一般的成员属性</li>
<li>常函数内部可以修改带mutable关键字的成员属性</li>
</ul>
<p>常对象：</p>
<ul>
<li>声明对象前加const关键字，这种对象称为常对象</li>
<li>不允许修改常对象的普通属性，但是可以修改其mutable属性</li>
<li>常对象只能调用常函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">int</span> ID;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showNameAndAge</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="comment">//实际上const修饰的是this指针，这样this指针就成为了指向常量的指针常量，自然不能再修改指向对象的内容</span></span><br><span class="line">		age = <span class="number">20</span>;</span><br><span class="line">		<span class="comment">//ID = 370784; 报错：表达式必须为可修改的左值</span></span><br><span class="line">		cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">showClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> Student stu;</span><br><span class="line">	stu.age = <span class="number">10</span>;	<span class="comment">//可以修改mutable属性</span></span><br><span class="line">	stu.<span class="built_in">showNameAndAge</span>();</span><br><span class="line">	<span class="comment">//stu.ID = 101; 不允许修改常对象的一般属性</span></span><br><span class="line">	<span class="comment">//stu.showClassName(); 不可以调用常对象的非const函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-友元"><a href="#5-友元" class="headerlink" title="5.友元"></a>5.友元</h3><p>如果在程序中，有些私有成员也想让类外的一些函数或者其他类进行访问，就需要用到友元技术，其关键字为friend，使用友元的目的就是让类外部的一个函数或者其他类访问该类的私有成员</p>
<p>友元的三种实现：</p>
<ul>
<li>全局函数作友元</li>
<li>其他类作友元</li>
<li>其他类的成员函数作友元</li>
</ul>
<h4 id="5-1全局函数作友元"><a href="#5-1全局函数作友元" class="headerlink" title="5.1全局函数作友元"></a>5.1全局函数作友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodFriend</span><span class="params">(Person&amp; p)</span></span>;<span class="comment">//友元实现</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodFriend</span><span class="params">(Person&amp; p)</span> </span>&#123;<span class="comment">//全局函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;因为我是他的好朋友，他告诉了我他的年龄是：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person ps = <span class="built_in">Person</span>(<span class="string">&quot;LiHua&quot;</span>, <span class="number">19</span>);</span><br><span class="line">	<span class="built_in">goodFriend</span>(ps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2其他类作友元"><a href="#5-2其他类作友元" class="headerlink" title="5.2其他类作友元"></a>5.2其他类作友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodFriend</span>;</span><span class="comment">//友元实现</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">hisAge</span><span class="params">(Person&amp; p)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是他的好朋友，他告诉了我他的年龄是：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person ps = <span class="built_in">Person</span>(<span class="string">&quot;LiHua&quot;</span>, <span class="number">19</span>);</span><br><span class="line">	goodFriend gf;</span><br><span class="line">	gf.<span class="built_in">hisAge</span>(ps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3成员函数作友元"><a href="#5-3成员函数作友元" class="headerlink" title="5.3成员函数作友元"></a>5.3成员函数作友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//下面的类和成员函数的定义顺序必须要注意</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span>	<span class="comment">//goodFriend类中需要用到Person类，需要先声明一下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodFriend</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">hisAge</span><span class="params">(Person&amp; p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//因为Person类还未定义所以不可以在这里定义用到Person类的函数</span></span><br><span class="line"><span class="comment">//void goodFriend::hisAge(Person&amp; p) &#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;我是他的好朋友，他告诉了我他的年龄是：&quot; &lt;&lt; p.age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><span class="comment">//Person类的实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodFriend::hisAge</span><span class="params">(Person&amp; p)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodFriend::hisAge</span><span class="params">(Person&amp; p)</span> </span>&#123;<span class="comment">//现在Person类已经定义，所以可以定义使用到Person类的函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;我是他的好朋友，他告诉了我他的年龄是：&quot;</span> &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person ps = <span class="built_in">Person</span>(<span class="string">&quot;LiHua&quot;</span>, <span class="number">19</span>);</span><br><span class="line">	goodFriend gf;</span><br><span class="line">	gf.<span class="built_in">hisAge</span>(ps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-运算符重载"><a href="#6-运算符重载" class="headerlink" title="6.运算符重载"></a>6.运算符重载</h3><p>运算符重载的概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="6-1加号运算符重载"><a href="#6-1加号运算符重载" class="headerlink" title="6.1加号运算符重载"></a>6.1加号运算符重载</h4><p>作用：实现两个自定义数据类型的相加运算</p>
<p>解释：对于内置的数据类型，编译器知道如何进行运算，但是对于自定义类型，编译器就不知道两个对象相加要实现的功能是什么了（比如，是实现全部成员属性各自相加还是部分成员属性各自相加呢，还是其他某种情况呢？编译器是不知道的），这时候就需要我们对加法进行重载</p>
<ul>
<li><p>成员函数实现加号运算符重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> money;<span class="comment">//人持有的钱</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> money) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现加号运算符重载</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>+(Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.money = <span class="keyword">this</span>-&gt;money + p.money;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//p1持有两块钱</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">3</span>)</span></span>;<span class="comment">//p2持有三块钱</span></span><br><span class="line">	Person p3 = p1 + p2;<span class="comment">//创建对象p3，且p3持有的金钱量是p1和p2两人的金钱和</span></span><br><span class="line">	<span class="comment">//本质上是Person p3 = p1.operator+(p2);</span></span><br><span class="line">    cout &lt;&lt; p3.money &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>全局函数实现加号运算符重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> money;<span class="comment">//人持有的钱</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> money) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = money;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数实现加号运算符重载</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2) &#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.money = p1.money + p2.money;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//p1持有两块钱</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">3</span>)</span></span>;<span class="comment">//p2持有三块钱</span></span><br><span class="line">	Person p3 = p1 + p2;</span><br><span class="line">	<span class="comment">//本质是 Person p3 = operator+(p1, p2);</span></span><br><span class="line">	cout &lt;&lt; p3.money &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>运算符重载函数也会发生函数重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> money;<span class="comment">//人持有的钱</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> money) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = money;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数实现加号运算符重载</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2) &#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.money = p1.money + p2.money;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person&amp; <span class="keyword">operator</span>+(Person&amp; p, <span class="keyword">int</span> money) &#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.money = p.money + money;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//p1持有两块钱</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">3</span>)</span></span>;<span class="comment">//p2持有三块钱</span></span><br><span class="line">	Person p3 = p1 + p2;</span><br><span class="line">	<span class="comment">//本质是 Person p3 = operator+(p1, p2);</span></span><br><span class="line">	Person p4 = p1 + <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//本质是 Person p4 = operator+(p1, 10);</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p3 = p1 + p2，所以p3.money是&quot;</span> &lt;&lt; p3.money &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p4 = p1 + 10，所以p4.money是&quot;</span> &lt;&lt; p4.money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">p3 = p1 + p2，所以p3.money是<span class="number">5</span></span><br><span class="line">p4 = p1 + <span class="number">10</span>，所以p4.money是<span class="number">12</span></span><br><span class="line">思考：通过成员函数如何实现p4 = p1 + <span class="number">10</span>呢? </span><br><span class="line">解：	</span><br><span class="line">    Person&amp; <span class="keyword">operator</span>+(<span class="keyword">int</span> money) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.money = <span class="keyword">this</span>-&gt;money + money;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结：</p>
<ul>
<li>总结1：对于运算内置的数据类型的运算符，是不可以改变的（比如想通过运算符重载实现 1+1=0 这是不可以的）</li>
<li>总结2：不要滥用运算符重载（比如加号运算符重载中实际实现了减法运算等，引起不必要的误会）</li>
</ul>
</li>
</ul>
<h4 id="6-2左移运算符”-lt-lt-”重载"><a href="#6-2左移运算符”-lt-lt-”重载" class="headerlink" title="6.2左移运算符”&lt;&lt;”重载"></a>6.2左移运算符”&lt;&lt;”重载</h4><p>作用：实现自定义数据类型的输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数无法实现 cout&lt;&lt;p ，只能实现 p&lt;&lt;cout</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数实现</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp;myout, Person&amp; p) &#123;<span class="comment">//因为cout全局只能有一个，不能创建一个新的，所以用引用方式传递</span></span><br><span class="line">	<span class="comment">//本质是 operator&lt;&lt;(myout,p) 因为是引用方式传递的，所以myout是cout的别名，是同一个对象</span></span><br><span class="line">	<span class="comment">//这样就可以简化为 myout&lt;&lt;p</span></span><br><span class="line">	cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">ps</span><span class="params">(<span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; ps; <span class="comment">//现在还不可以多个&lt;&lt;连续输出,连续输出需要改进</span></span><br><span class="line">    <span class="comment">//本质上是 operator&lt;&lt;(cout,ps);</span></span><br><span class="line">    <span class="comment">//简化为 cout &lt;&lt; ps</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//********************************************************************************************************************</span></span><br><span class="line"><span class="comment">//********************************************************改进********************************************************</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数无法实现 cout&lt;&lt;p ，只能实现 p&lt;&lt;cout</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数实现</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;myout, Person&amp; p) &#123;<span class="comment">//同样因为cout只能有一个，所以以引用方式返回</span></span><br><span class="line">	myout &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.age;</span><br><span class="line">	<span class="keyword">return</span> myout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">ps</span><span class="params">(<span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; ps &lt;&lt; <span class="string">&quot;连续输出(链式编程思想)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结：重载左移运算符配合友元（当类的属性为private时，就需要把重载运算符函数声明为类的友元）可以实现输出自定义数据类型</li>
</ul>
<h4 id="6-3自增运算符重载"><a href="#6-3自增运算符重载" class="headerlink" title="6.3自增运算符重载"></a>6.3自增运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> money;</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		money = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> money) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; <span class="keyword">operator</span>++() &#123;<span class="comment">//前置自增 可以实现连续自增</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;money++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> Person <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="comment">//占位参数只能用int，通过它告诉编译器这是后置自增</span></span><br><span class="line">		Person temp = *<span class="keyword">this</span>; <span class="comment">//暂存</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;money++;</span><br><span class="line">		<span class="keyword">return</span> temp;<span class="comment">//返回暂存对象（局部变量），不能以引用方式返回，只能用值方式返回，拷贝一份副本，这也是为什么后置自增速度比前置递自慢的原因</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">ps</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; (++(++ps)).money &lt;&lt; endl;<span class="comment">//前置自增 可以实现连续自增</span></span><br><span class="line">	cout &lt;&lt; ps.money &lt;&lt; endl;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; (p++).money &lt;&lt; endl;<span class="comment">//后置自增不可以实现连续自增 因为第二次自增操作是对返回的新对象temp的副本的自增</span></span><br><span class="line">	cout &lt;&lt; p.money &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：前置递增以引用方式返回，后置递增以值方式返回</p>
<h4 id="6-4赋值运算符重载"><a href="#6-4赋值运算符重载" class="headerlink" title="6.4赋值运算符重载"></a>6.4赋值运算符重载</h4><p>注意点（学习侯捷C++后补充的）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">Person p2 = p1; <span class="comment">//这是拷贝构造的隐式转换（p2刚被创建） 等同于Person p2(p1);</span></span><br><span class="line">Person p3;</span><br><span class="line">p3 = p2;	<span class="comment">//这是赋值操作（p3被赋值）</span></span><br></pre></td></tr></table></figure>

<p>C++编译器实际上除了给类添加默认构造函数、默认析构函数、默认拷贝构造函数外，还会提供一个默认的赋值运算符“=”的重载函数，实现对属性的拷贝。</p>
<ul>
<li><p>但这种拷贝是浅拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span>* age;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/*打开这个析构函数后，程序会报错，因为func()函数执行结束时会重复释放同一块内存空间（转至 类和对象-&gt;2.4深拷贝与浅拷贝）</span></span><br><span class="line"><span class="comment">    ~Person() &#123;</span></span><br><span class="line"><span class="comment">		if (this-&gt;age != NULL) &#123;</span></span><br><span class="line"><span class="comment">			delete this-&gt;age;</span></span><br><span class="line"><span class="comment">			this-&gt;age = NULL;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">ps</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; ps.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *ps.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p.age &lt;&lt; endl;</span><br><span class="line">	ps = p;	<span class="comment">//浅拷贝</span></span><br><span class="line">	cout &lt;&lt; ps.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *ps.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">013B</span>DA00</span><br><span class="line"><span class="number">013B</span>DA30</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">013B</span>DA30	<span class="comment">//ps.age指向了p.age所指的内存空间，拷贝的是地址</span></span><br><span class="line"><span class="number">013B</span>DA30	</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></li>
<li><p>我们需要自己编写赋值运算符重载函数实现深拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span>* age;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">			<span class="keyword">this</span>-&gt;age = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 C++规定了operator=只能是成员函数</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(Person&amp; p) &#123;</span><br><span class="line">		*<span class="keyword">this</span>-&gt;age = *p.age;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">ps</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; ps.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *ps.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p.age &lt;&lt; endl;</span><br><span class="line">	ps = p;	<span class="comment">//深拷贝</span></span><br><span class="line">	cout &lt;&lt; ps.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *ps.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p.age &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也可以实现下面的链式赋值操作</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	p3 = p2 = p1;</span><br><span class="line">	cout &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p1.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p2.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p3.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">0110</span>DA00</span><br><span class="line"><span class="number">0110</span>DA30</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">0110</span>DA00  </span><br><span class="line"><span class="number">0110</span>DA30	</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="comment">//链式赋值操作的结果</span></span><br><span class="line"><span class="number">0127</span>DA00</span><br><span class="line"><span class="number">0127</span>DA30</span><br><span class="line"><span class="number">01274</span>A30</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-5关系运算符重载"><a href="#6-5关系运算符重载" class="headerlink" title="6.5关系运算符重载"></a>6.5关系运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> money;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="keyword">int</span> money) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Person&amp; p) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;money &gt; p.money ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">////全局函数实现</span></span><br><span class="line"><span class="comment">//bool operator&gt;(Person&amp; p1, Person&amp; p) &#123;</span></span><br><span class="line"><span class="comment">//	return p1.money &gt; p.money ? true : false;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; (p1 &gt; p2) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (p1 &gt; p3) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; (p1 &gt; p4) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//那么，&lt;，&gt;=，&lt;=，==，!=，它们如何重载呢？</span></span><br></pre></td></tr></table></figure>

<h4 id="6-6函数调用运算符重载"><a href="#6-6函数调用运算符重载" class="headerlink" title="6.6函数调用运算符重载"></a>6.6函数调用运算符重载</h4><ul>
<li><p>函数调用运算符()也可以重载</p>
</li>
<li><p>由于重载后使用的方式非常像函数的调用，因此也被称为仿函数</p>
</li>
<li><p>仿函数没有固定的写法，非常灵活</p>
</li>
<li><p>示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//C++规定opeartor()也必须是成员函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 + num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	AddInteger addInt;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="built_in">addInt</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">	cout &lt;&lt; sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-继承"><a href="#7-继承" class="headerlink" title="7.继承"></a>7.继承</h3><h4 id="7-1继承的基本语法"><a href="#7-1继承的基本语法" class="headerlink" title="7.1继承的基本语法"></a>7.1继承的基本语法</h4><ul>
<li><p>优点：减少代码量，提高代码复用性</p>
</li>
<li><p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span>继承方式 B&#123;&#125;;	<span class="comment">//A称为子类或派生类 B称为父类或基类</span></span><br></pre></td></tr></table></figure></li>
<li><p>派生类中的成员，包含两大部分：</p>
<ul>
<li>一部分是从基类继承过来的，一部分是自己增加的成员</li>
<li>从基类继承过来的成员表现其共性，而新增的成员体现了其个性</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> stuID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span><span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> teaID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Student stu;</span><br><span class="line">	stu.name = <span class="string">&quot;LiHua&quot;</span>;</span><br><span class="line">	stu.age = <span class="number">19</span>;</span><br><span class="line">	stu.stuID = <span class="number">120190201</span>;</span><br><span class="line">	Teacher th;</span><br><span class="line">	th.name = <span class="string">&quot;WangXiang&quot;</span>;</span><br><span class="line">	th.age = <span class="number">37</span>;</span><br><span class="line">	th.teaID = <span class="number">220190211</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();       </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-2继承方式"><a href="#7-2继承方式" class="headerlink" title="7.2继承方式"></a>7.2继承方式</h4><p>继承方式一共有三种：public继承、protected继承、private继承</p>
<ul>
<li><p>当public继承的时候，父类中public类型的成员会被继承到子类的public中去，而父类的protected成员也会被继承到子类的protected中去</p>
</li>
<li><p>当protected继承的时候，父类中无论是public的还是protected的成员都会被继承到子类的protected中去</p>
</li>
<li><p>当private继承的时候，父类中 public 和 protected 的成员都会被继承到子类的private中去</p>
</li>
</ul>
<p><strong>关于父类的private成员</strong>：C++与Java一样，子类会继承父类的全部属性和方法，但是对于父类的private成员，子类不可以直接访问，需要通过由继承父类得到的public成员函数来访问这些成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//保护权限的成员可以在子类中访问</span></span><br><span class="line">	<span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> num3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printInFather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Father &#123;<span class="comment">//公共继承</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">protected</span> Father &#123;<span class="comment">//保护继承</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span> :</span><span class="keyword">private</span> Father &#123;<span class="comment">//私有继承</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandson1</span> :</span><span class="keyword">public</span> Son1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; num1 &lt;&lt; endl;<span class="comment">//num1是Son1类的公共属性</span></span><br><span class="line">		cout &lt;&lt; num2 &lt;&lt; endl;<span class="comment">//num2是Son1类的保护属性，Grandson1是Son1的子类，可以访问其保护属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; num3 &lt;&lt; endl;//num3虽然由Father继承给了Son1，但是即使是Son1也不可以直接访问Father的私有属性，Grandson1就更不可以了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandson2</span> :</span><span class="keyword">public</span> Son2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; num1 &lt;&lt; endl;<span class="comment">//num1是Son2类的保护属性，Grandson2是Son2的子类，可以访问其保护属性</span></span><br><span class="line">		cout &lt;&lt; num2 &lt;&lt; endl;<span class="comment">//num2是Son2类的保护属性，Grandson2是Son2的子类，可以访问其保护属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; num3 &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandson3</span> :</span><span class="keyword">public</span> Son3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; num1 &lt;&lt; endl;//num1是Son3类的私有属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; num2 &lt;&lt; endl;//num2是Son3类的私有属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; num3 &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son1 son1;</span><br><span class="line">	son1.<span class="built_in">printInFather</span>();<span class="comment">//printInFather()是由继承父类得到的公共成员函数，可以通过这类方法调用父类的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();       </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3继承中的对象模型"><a href="#7-3继承中的对象模型" class="headerlink" title="7.3继承中的对象模型"></a>7.3继承中的对象模型</h4><p>问题：从父类继承过来的成员，哪些存储在子类对象中？</p>
<p>解答：父类中所有的非静态成员变量都存储在子类对象中，只不过private权限的成员变量不允许子类对象直接访问</p>
<h4 id="7-4继承中构造和析构的顺序"><a href="#7-4继承中构造和析构的顺序" class="headerlink" title="7.4继承中构造和析构的顺序"></a>7.4继承中构造和析构的顺序</h4><p>子类继承父类后，在我们创建子类对象时，也会调用父类的构造函数</p>
<p>那么问题来了：父类和子类的构造和析构的顺序是谁先谁后呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Father</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Father的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Father</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Father的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();       </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Father的构造函数</span><br><span class="line">Son的构造函数</span><br><span class="line">Son的析构函数</span><br><span class="line">Father的析构函数</span><br></pre></td></tr></table></figure>

<h4 id="7-5继承中同名成员的处理方式"><a href="#7-5继承中同名成员的处理方式" class="headerlink" title="7.5继承中同名成员的处理方式"></a>7.5继承中同名成员的处理方式</h4><p>问题：当子类与父类中出现同名的成员时，如何通过子类对象，访问子类或父类中同名的成员呢？</p>
<p>解答：</p>
<ul>
<li><p>访问子类中同名成员时，直接访问即可</p>
</li>
<li><p>访问继承父类得到的同名成员时，需要加父类作用域</p>
</li>
<li><p>（学习侯捷C++后的补充）当子类继承父类后，若子类中没有与父类同名的普通成员函数，我们用子类对象调用函数实际上调用的是父类作用域下的成员函数，但若子类中具有同名的成员函数，我们用子类对象调用的实际上是子类作用域下的成员函数，这时子类对象有两份同名的成员函数，一份是父类下的，一份是子类下的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;...&#125;;</span><br><span class="line"><span class="comment">//假设A中有print成员函数，而B中没有</span></span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">print</span>();	<span class="comment">//实际是 b.A::print();</span></span><br><span class="line"><span class="comment">//假设B中也有print</span></span><br><span class="line">b.<span class="built_in">print</span>();	<span class="comment">//实际是 b.B::print();</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">Father</span>() &#123;</span><br><span class="line">		age = <span class="number">45</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Father中的fun()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Father中的fun(int num)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">Son</span>() &#123;</span><br><span class="line">		age = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son中的fun()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son的age是：&quot;</span> &lt;&lt; son.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Father的age是：&quot;</span> &lt;&lt; son.Father::age &lt;&lt; endl;</span><br><span class="line">	son.<span class="built_in">fun</span>();</span><br><span class="line">	<span class="comment">//son.fun(100); 错误，因为子类中的fun()会隐藏掉父类中所有的同名成员函数</span></span><br><span class="line">	son.Father::<span class="built_in">fun</span>(<span class="number">100</span>);</span><br><span class="line">	son.Father::<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();       </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Son的age是：<span class="number">20</span></span><br><span class="line">Father的age是：<span class="number">45</span></span><br><span class="line">Son中的<span class="built_in">fun</span>()调用</span><br><span class="line">Father中的<span class="built_in">fun</span>(<span class="keyword">int</span> num)调用</span><br><span class="line">Father中的<span class="built_in">fun</span>()调用</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>子类对象可以直接访问子类中的同名成员</li>
<li>子类对象加父类作用域才能访问继承父类得到的同名成员</li>
<li>当子类与父类存在同名的成员函数时，子类会隐藏掉继承父类得到的所有的同名成员函数，即便参数列表不同，也仍需要加父类作用域才能访问到继承父类得到的同名成员函数</li>
</ul>
<h4 id="7-6继承中同名静态成员的处理方式"><a href="#7-6继承中同名静态成员的处理方式" class="headerlink" title="7.6继承中同名静态成员的处理方式"></a>7.6继承中同名静态成员的处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问呢？</p>
<p>解答：</p>
<p>静态成员出现同名情况时，处理方法与非静态成员相同</p>
<ul>
<li>访问子类中同名成员时，直接访问即可</li>
<li>访问继承父类得到的同名成员时，需要加父类作用域</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> age;<span class="comment">//static</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Father中的fun()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Father::age = <span class="number">45</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son中的fun()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Son::age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Son son;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son的age是：&quot;</span> &lt;&lt; son.age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Father的age是：&quot;</span> &lt;&lt; son.Father::age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类名方式访问：Son的age是：&quot;</span> &lt;&lt; Son::age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类名方式访问：Father的age是：&quot;</span> &lt;&lt; Son::Father::age &lt;&lt; endl;</span><br><span class="line">	son.<span class="built_in">fun</span>();</span><br><span class="line">	son.Father::<span class="built_in">fun</span>();</span><br><span class="line">	Son::<span class="built_in">fun</span>();</span><br><span class="line">	Son::Father::<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：同名静态成员处理方式和非静态成员处理方式一样，不过有通过对象访问和通过类名访问两种方式</p>
<h4 id="7-7多继承"><a href="#7-7多继承" class="headerlink" title="7.7多继承"></a>7.7多继承</h4><p>C++允许一个类继承多个类（这点与Java不同）</p>
<ul>
<li><p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Father1, <span class="keyword">protected</span> Father2...&#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>当多个父类中存在同名成员时，我们通过子类调用该对象继承父类得到的同名成员时，需要加作用域区分</p>
</li>
<li><p>实际开发中，不建议使用多继承</p>
</li>
</ul>
<h4 id="7-8虚继承"><a href="#7-8虚继承" class="headerlink" title="7.8虚继承"></a>7.8虚继承</h4><p>菱形继承（钻石继承）概念：</p>
<ul>
<li>两个派生类继承同一个基类</li>
<li>又有某个类继承了这两个派生类</li>
</ul>
<p>问题：最后的子类继承到了具有相同意义的两个变量，浪费资源</p>
<p>解决：使用虚继承解决这个问题</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span><span class="keyword">public</span> Person &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pupil</span>:</span> <span class="keyword">public</span> Student, <span class="keyword">public</span> Child &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pupil pp;</span><br><span class="line">	<span class="comment">//pp.age = 12; 报错：Pupil::age不明确</span></span><br><span class="line">	pp.Student::age = <span class="number">12</span>;</span><br><span class="line">	pp.Child::age = <span class="number">12</span>;</span><br><span class="line">	<span class="comment">//上述操作可行，但pp中存在两份相同意义（表示年龄）的变量，一份继承自Student，一份继承自Child</span></span><br><span class="line">    <span class="comment">//此时sizeof(pp) = 8，因为其中有两份int类型的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*************************************************************************</span></span><br><span class="line"><span class="comment">//******************************解决方法************************************</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Person &#123;<span class="comment">//虚继承 称Person为虚基类</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Person &#123;<span class="comment">//虚继承</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pupil</span> :</span> <span class="keyword">public</span> Student, <span class="keyword">public</span> Child &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Pupil pp;</span><br><span class="line">	pp.age = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-多态"><a href="#8-多态" class="headerlink" title="8.多态"></a>8.多态</h3><h4 id="8-1多态的基本概念"><a href="#8-1多态的基本概念" class="headerlink" title="8.1多态的基本概念"></a>8.1多态的基本概念</h4><p>多态分为两类：</p>
<ul>
<li>静态多态：函数重载和运算符重载属于静态多态，复用函数和运算符</li>
<li>动态多态：派生类和虚函数实现运行时（动态）多态</li>
</ul>
<p>静态多态和动态多态的区别：</p>
<ul>
<li>静态多态的函数地址早绑定-编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定-运行阶段确定函数地址</li>
</ul>
<p>动态多态的条件：</p>
<ul>
<li>存在继承关系</li>
<li>子类重写父类中的虚函数（重写：函数的返回值类型 函数名 形参列表完全一致）</li>
</ul>
<p>动态多态的使用：需要父类的指针或引用指向子类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;喵喵喵&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;汪汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; am)</span> </span>&#123;</span><br><span class="line">	am.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	Animal&amp; am0 = cat; <span class="comment">//父类引用指向一个子类对象</span></span><br><span class="line">	am0.<span class="built_in">speak</span>();</span><br><span class="line">	Animal* am1 = &amp;cat;<span class="comment">//父类指针指向一个子类对象</span></span><br><span class="line">	am1-&gt;<span class="built_in">speak</span>();</span><br><span class="line">	<span class="built_in">doSpeak</span>(cat);<span class="comment">//父类引用类型的形式参数接收一个子类对象</span></span><br><span class="line"></span><br><span class="line">	Animal am2 = cat; <span class="comment">//将子类对象赋值给父类变量不能实现多态</span></span><br><span class="line">	am2.<span class="built_in">speak</span>();<span class="comment">//打印 动物叫</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">喵喵喵</span><br><span class="line">喵喵喵</span><br><span class="line">喵喵喵</span><br><span class="line">动物叫</span><br></pre></td></tr></table></figure>

<h4 id="8-2多态的原理剖析"><a href="#8-2多态的原理剖析" class="headerlink" title="8.2多态的原理剖析"></a>8.2多态的原理剖析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//sizeof(Animal) = 1; 因为Animal对象上不会存储任何结构（只有非静态成员变量存储在对象上）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizoeof(Animal) = 4</span></span><br><span class="line"><span class="comment">原因是Animal对象上会存放一个vfptr指针（虚函数指针）</span></span><br><span class="line"><span class="comment">vfptr指针指向vftable（虚函数表）</span></span><br><span class="line"><span class="comment">vftable中存放的是虚函数地址 &amp;Animal::speak</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Cat会继承Animal中的全部成员（属性和函数）</span></span><br><span class="line"><span class="comment">所以Cat中继承到了vfptr指针，所以sizeof(Cat) = 4</span></span><br><span class="line"><span class="comment">同样vfptr指针指向了vftable</span></span><br><span class="line"><span class="comment">当Cat不对Animal中的虚函数Animal::speak重写时</span></span><br><span class="line"><span class="comment">vftable中存放的是虚函数地址 &amp;Animal::speak</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line">	 <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;喵喵喵&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Cat会继承Animal中的全部成员（属性和函数）</span></span><br><span class="line"><span class="comment">所以Cat中继承到了vfptr指针</span></span><br><span class="line"><span class="comment">同样vfptr指针指向了vftable</span></span><br><span class="line"><span class="comment">但是如果Cat重写了Animal中的虚函数Animal::speak</span></span><br><span class="line"><span class="comment">vftable中存放的是虚函数地址 &amp;Cat::speak</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//这种情况下，如果Animal类的引用或者指针指向了Cat类的对象，如下</span></span><br><span class="line">Cat cat;</span><br><span class="line">Animal&amp; am = cat;</span><br><span class="line">Animal* am = &amp;cat;</span><br><span class="line">Animal* am = <span class="keyword">new</span> Cat;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">就会发生多态，我们用am调用speak函数时，因为对象本身是Cat类的对象，所以调用的是Cat::speak</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="8-3纯虚函数和抽象类"><a href="#8-3纯虚函数和抽象类" class="headerlink" title="8.3纯虚函数和抽象类"></a>8.3纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是无意义的，主要用于调用子类重写的内容，因此可以将虚函数改为纯虚函数，当某个类中有了纯虚函数，该类就被称为抽象类</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名(形参列表) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>抽象类的特点：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则该子类也属于抽象类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数(不可以定义，必须由子类定义)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;汪汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Animal am; 报错，原因是抽象类不可以实例化对象</span></span><br><span class="line">	<span class="comment">//new Animal; 报错，原因是抽象类不可以实例化对象</span></span><br><span class="line">	<span class="comment">//Cat cat; 报错，原因是Cat类中没有重写Animal的纯虚函数，Cat类也是一个抽象类</span></span><br><span class="line">	Dog dog0;	<span class="comment">//正确</span></span><br><span class="line">	Animal* dog1 = <span class="keyword">new</span> Dog;<span class="comment">//发生多态</span></span><br><span class="line">	dog1-&gt;<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4虚析构和纯虚析构"><a href="#8-4虚析构和纯虚析构" class="headerlink" title="8.4虚析构和纯虚析构"></a>8.4虚析构和纯虚析构</h4><p>问题：使用多态时，如果子类中有属性开辟到了堆区，那么父类指针（或引用）在释放时无法调用到子类的析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string* name;</span><br><span class="line">	<span class="built_in">Cat</span>(string name) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">			<span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;喵喵喵&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Animal* cat = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	cat-&gt;<span class="built_in">speak</span>();</span><br><span class="line">	<span class="keyword">delete</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Animal的构造函数</span><br><span class="line">Cat的构造函数</span><br><span class="line">喵喵喵</span><br><span class="line"><span class="comment">//这里没有调用到Cat类的析构函数</span></span><br><span class="line">Animal的析构函数</span><br></pre></td></tr></table></figure>

<p>解决方法：将父类的析构函数改为虚析构或者纯虚析构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;<span class="comment">//虚析构</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal的虚析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Animal的构造函数</span><br><span class="line">Cat的构造函数</span><br><span class="line">喵喵喵</span><br><span class="line">Cat的析构函数</span><br><span class="line">Animal的虚析构</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;	<span class="comment">//纯虚析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;<span class="comment">//纯虚析构函数的实现（也可以在类内部实现）</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal的纯虚析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虚析构和纯虚析构的共性：</p>
<ul>
<li>使得父类指针（或引用）可以释放子类对象中开辟到堆区的属性</li>
<li>都需要有具体的函数实现（因为父类中也可能存在开辟到堆区的属性，需要通过析构函数释放）</li>
</ul>
<p>虚析构和纯虚析构的区别：</p>
<ul>
<li>如果某类中存在的是纯虚析构，则该类属于抽象类，无法实例化对象</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束，这些数据就会被释放，通过文件可以将数据保存下来，C++中文件操作需要包含头文件&lt;fstream&gt;（文件流类）</p>
<p>文件类型分为两类：</p>
<ul>
<li>文本文件：文件以文本的ASCII码形式存储在计算机中</li>
<li>二进制文件：文件以文本的二进制形式存储在计算机中</li>
</ul>
<p>三类文件操作：</p>
<ul>
<li>ofstream：写文件</li>
<li>ifstream：读文件</li>
<li>fstream：读写文件</li>
</ul>
<h3 id="1-写文件"><a href="#1-写文件" class="headerlink" title="1.写文件"></a>1.写文件</h3><p>步骤：</p>
<ol>
<li>包含头文件 #include&lt;fstream&gt;</li>
<li>创建流对象 ofstream ofs;</li>
<li>打开文件 ofs.open(“文件路径”,打开方式);</li>
<li>写数据 ofs&lt;&lt;”写入的信息”;</li>
<li>关闭文件 ofs.close();</li>
</ol>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读取文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为 写入文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置为文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>先删除文件再创建新的</td>
</tr>
<tr>
<td>ios::binary</td>
<td>以二进制方式读写文件</td>
</tr>
</tbody></table>
<p>注意：文件打开方式可以利用“|”操作符来配合使用</p>
<p>例如：ios::binary | ios::out 以二进制方式写文件</p>
<h3 id="2-读文件"><a href="#2-读文件" class="headerlink" title="2.读文件"></a>2.读文件</h3><p>步骤：</p>
<ol>
<li>包含头文件 #include&lt;fstream&gt;</li>
<li>创建流对象 ifstream ifs;</li>
<li>打开文件 ifs.open(“文件路径”,打开方式);</li>
<li>判断是否打开成功 ifs.is_open()</li>
<li>读数据 四种读取方式</li>
<li>关闭文件 ofs.close();</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.<span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\74615\\Desktop\\test.txt&quot;</span>, ios::in);</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//读数据方式：</span></span><br><span class="line">	<span class="comment">//第一种：一次读取遇到空格、换行、制表符结束</span></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;<span class="comment">//读完则返回false </span></span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;次读取&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="comment">//第二种：一次读取一行</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	char buf[1024] = &#123; 0 &#125;; </span></span><br><span class="line"><span class="comment">	int cnt = 1;</span></span><br><span class="line"><span class="comment">	while (ifs.getline(buf,sizeof(buf))) &#123;//读完则返回false </span></span><br><span class="line"><span class="comment">		cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;第&quot; &lt;&lt; cnt &lt;&lt; &quot;次读取&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cnt++;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	ifs.close();*/</span></span><br><span class="line">	<span class="comment">//第三种：利用string读取 一次读取一行</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	string buf;</span></span><br><span class="line"><span class="comment">	int cnt = 1;</span></span><br><span class="line"><span class="comment">	while (getline(ifs,buf)) &#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;第&quot; &lt;&lt; cnt &lt;&lt; &quot;次读取&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cnt++;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	ifs.close();*/</span></span><br><span class="line">	<span class="comment">//第四种（不常用）：逐字符读取（效率低），这种方式会读到空格、制表符和换行</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	char c;</span></span><br><span class="line"><span class="comment">	int cnt = 1;</span></span><br><span class="line"><span class="comment">	while ((c = ifs.get()) != EOF) &#123;//读到文件尾则停止循环</span></span><br><span class="line"><span class="comment">		//这里再交代一下EOF是什么</span></span><br><span class="line"><span class="comment">		//EOF全称end of file，表示文件末尾</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;第&quot; &lt;&lt; cnt &lt;&lt; &quot;次读取&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cnt++;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	ifs.close();*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何判断文件是否为空：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ifs &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span>(ifs.<span class="built_in">eof</span>())&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;文件为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>



<h3 id="3-二进制方式写文件"><a href="#3-二进制方式写文件" class="headerlink" title="3.二进制方式写文件"></a>3.二进制方式写文件</h3><p>二进制方式写文件不仅可以操作内置数据类型，还可以操作自定义数据类型</p>
<p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream&amp; <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buffer, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">//字符指针buffer指向内存中一段存储空间，len是读写的字节数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;C:\\Users\\74615\\Desktop\\test.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">	Person ps = &#123;<span class="string">&quot;LiHua&quot;</span>, <span class="number">18</span>&#125;;<span class="comment">//结构体初始化方式</span></span><br><span class="line">	ofs.<span class="built_in">write</span>((<span class="keyword">const</span> <span class="keyword">char</span>*)&amp;ps, <span class="built_in"><span class="keyword">sizeof</span></span>(ps));</span><br><span class="line">	ofs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-二进制方式读文件"><a href="#4-二进制方式读文件" class="headerlink" title="4.二进制方式读文件"></a>4.二进制方式读文件</h3><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream&amp; <span class="title">read</span><span class="params">(<span class="keyword">char</span>* buffer, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;C:\\Users\\74615\\Desktop\\test.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打开文件失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	Person ps;</span><br><span class="line">	ifs.<span class="built_in">read</span>((<span class="keyword">char</span>*)&amp;ps, <span class="built_in"><span class="keyword">sizeof</span></span>(ps));</span><br><span class="line">	cout &lt;&lt; ps.name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; ps.age &lt;&lt; endl;</span><br><span class="line">	ifs.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-提高"><a href="#C-提高" class="headerlink" title="C++提高"></a>C++提高</h1><ul>
<li>主要学习C++泛型编程和STL技术</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>概念：模板就是建立通用的摸具，大大提高复用性</p>
<h3 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1.函数模板"></a>1.函数模板</h3><ul>
<li>C++除了面向对象的编程思想外，还有泛型编程思想，主要利用的技术就是模板</li>
<li>C++提供<strong>函数模板</strong>和<strong>类模板</strong>两种模板机制</li>
</ul>
<h4 id="1-1函数模板的使用"><a href="#1-1函数模板的使用" class="headerlink" title="1.1函数模板的使用"></a>1.1函数模板的使用</h4><p>函数模板的作用：建立一个通用函数，其返回值类型和形参类型可以不具体确定，而是用一个虚拟的类型来代替</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义;</span><br><span class="line"><span class="comment">/*解释：</span></span><br><span class="line"><span class="comment">template -- 声明创建模板</span></span><br><span class="line"><span class="comment">typename -- 表明后面的符号T是一种数据类型，可以用class代替</span></span><br><span class="line"><span class="comment">T -- 通用数据类型，名称自定义，通常使用大写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//typename可以用class替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; num1, T&amp; num2)</span> </span>&#123;</span><br><span class="line">	T temp = num1;</span><br><span class="line">	num1 = num2;</span><br><span class="line">	num2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//函数模板使用方法</span></span><br><span class="line">	<span class="comment">//方法1：自动类型推导</span></span><br><span class="line">	<span class="comment">//mySwap(a, b);		//根据a和b的类型推导出T类型为int</span></span><br><span class="line">	<span class="comment">//方法2：显式指定类型</span></span><br><span class="line">	mySwap&lt;<span class="keyword">int</span>&gt;(a, b);	<span class="comment">//显式指定出T类型就是int类型	</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//double a = 10.2;</span></span><br><span class="line">	<span class="comment">//double b = 20.1;</span></span><br><span class="line">	<span class="comment">//mySwap(a, b);</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T才可以使用（如上例中若a，b的类型不一致，则会报错）</li>
<li>模板必须确定了T的类型才可以使用（如当我们无法通过形参自动类型推导出T的类型时，我们必须显式指定T类型才可以使用函数）</li>
</ul>
<h4 id="1-2函数模板与普通函数的区别"><a href="#1-2函数模板与普通函数的区别" class="headerlink" title="1.2函数模板与普通函数的区别"></a>1.2函数模板与普通函数的区别</h4><p>区别：</p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果采用自动类型推导，不会发生隐式类型转换</li>
<li>函数模板采用显式指定类型，才会发生隐式类型转换</li>
</ul>
<h4 id="1-3函数模板与普通函数调用规则"><a href="#1-3函数模板与普通函数调用规则" class="headerlink" title="1.3函数模板与普通函数调用规则"></a>1.3函数模板与普通函数调用规则</h4><ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数（即便普通函数只是声明，没有定义，也不会调用函数模板，而是报错）</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">getSum</span><span class="params">(T num1, T num2)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">getSum</span><span class="params">(T num1, T num2, T num3)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;函数模板（三数之和）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2 + num3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">getSum</span>(a, b) &lt;&lt; endl;<span class="comment">//优先调用普通函数</span></span><br><span class="line">	cout &lt;&lt; getSum&lt;&gt;(a, b) &lt;&lt; endl;<span class="comment">//通过空模板参数列表强制调用函数模板</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">getSum</span>(a, b, c) &lt;&lt; endl;<span class="comment">//函数模板也可以发生重载</span></span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">10.2</span>;</span><br><span class="line">	<span class="keyword">double</span> f = <span class="number">20.1</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">getSum</span>(d, f) &lt;&lt; endl;<span class="comment">//函数模板可以更好地匹配时，会被优先调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">普通函数</span><br><span class="line"><span class="number">30</span></span><br><span class="line">函数模板</span><br><span class="line"><span class="number">30</span></span><br><span class="line">函数模板（三数之和）</span><br><span class="line"><span class="number">60</span></span><br><span class="line">函数模板</span><br><span class="line"><span class="number">30.3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4模板的局限性"><a href="#1-4模板的局限性" class="headerlink" title="1.4模板的局限性"></a>1.4模板的局限性</h4><p>局限性：模板的通用性并不是万能的。例如，当我们传入两个数组或者自定义数据类型，让他们完成赋值、比较、输出等操作时，代码是无法正常运行的</p>
<p>解决方法：C++提供了模板的重载，可以为这些特定的类型提供具体的模板</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T&amp; a,T&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a == b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体化Person类型版本的函数实现，可以优先被调用</span></span><br><span class="line"><span class="comment">//当我们传入的参数为Person类型时，优先执行的是下面的函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Person&amp; p1,Person&amp; p2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p1.name == p2.name &amp;&amp; p1.age == p2.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;LiHua&quot;</span>, <span class="number">17</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;LiHua&quot;</span>, <span class="number">17</span>)</span></span>;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="built_in">compare</span>(p1, p2);</span><br><span class="line">	cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用具体化的模板，可以使得自定义类型通用化</li>
<li>学习模板不是为了编写模板，而是能够运用STL中提供的模板，即为学习STL做铺垫</li>
</ul>
<h3 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2.类模板"></a>2.类模板</h3><h4 id="2-1类模板的使用"><a href="#2-1类模板的使用" class="headerlink" title="2.1类模板的使用"></a>2.1类模板的使用</h4><p>类模板的作用：</p>
<ul>
<li>建立一个通用类，类中成员变量和形参的数据类型可以不具体确定，而是用一个虚拟的类型来代表</li>
</ul>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类的定义</span><br><span class="line"><span class="comment">/*解释：</span></span><br><span class="line"><span class="comment">template -- 声明创建模板</span></span><br><span class="line"><span class="comment">typename -- 表明T是一种数据类型，可以用class代替</span></span><br><span class="line"><span class="comment">T -- 通用数据类型，名称自定义，通常使用大写字母</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//日期类</span></span><br><span class="line"><span class="comment">//因为我们的年月日分别可以是中文(字符串类型)也可以是数字(int类型)，所以我们采用类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>,<span class="keyword">class</span> <span class="title">M</span>,<span class="keyword">class</span> <span class="title">D</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Y year;</span><br><span class="line">	M month;</span><br><span class="line">	D day;</span><br><span class="line">	<span class="built_in">Date</span>(Y year, M month, D day) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;year = year;</span><br><span class="line">		<span class="keyword">this</span>-&gt;month = month;</span><br><span class="line">		<span class="keyword">this</span>-&gt;day = day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[year]: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;year &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[month]: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;month &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;[day]: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;day &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Date&lt;string,<span class="keyword">int</span>,string&gt; <span class="title">dt0</span><span class="params">(<span class="string">&quot;二零二一年&quot;</span>, <span class="number">2</span>, <span class="string">&quot;十一号&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Date&lt;string, string, string&gt; <span class="title">dt1</span><span class="params">(<span class="string">&quot;二零二一年&quot;</span>, <span class="string">&quot;二月&quot;</span>, <span class="string">&quot;十一号&quot;</span>)</span></span>;</span><br><span class="line">	<span class="function">Date&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">dt2</span><span class="params">(<span class="number">2021</span>, <span class="number">2</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">	dt0.<span class="built_in">print</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	dt1.<span class="built_in">print</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	dt2.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[year]: 二零二一年</span><br><span class="line">[month]: <span class="number">2</span></span><br><span class="line">[day]: 十一号</span><br><span class="line"></span><br><span class="line">[year]: 二零二一年</span><br><span class="line">[month]: 二月</span><br><span class="line">[day]: 十一号</span><br><span class="line"></span><br><span class="line">[year]: <span class="number">2021</span></span><br><span class="line">[month]: <span class="number">2</span></span><br><span class="line">[day]: <span class="number">11</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2类模板与函数模板的区别"><a href="#2-2类模板与函数模板的区别" class="headerlink" title="2.2类模板与函数模板的区别"></a>2.2类模板与函数模板的区别</h4><p>区别：</p>
<ul>
<li><p>类模板没有自动类型推导的使用方式，必须显式指定类型</p>
</li>
<li><p>类模板的模板参数列表可以有默认参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>, <span class="keyword">class</span> <span class="title">M</span>, <span class="keyword">class</span> <span class="title">D</span> =</span> <span class="keyword">int</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Y year;</span><br><span class="line">	M month;</span><br><span class="line">	D day;</span><br><span class="line">	<span class="built_in">Date</span>(Y year, M month, D day) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;year = year;</span><br><span class="line">		<span class="keyword">this</span>-&gt;month = month;</span><br><span class="line">		<span class="keyword">this</span>-&gt;day = day;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Date&lt;string, <span class="keyword">int</span>&gt; <span class="title">dt0</span><span class="params">(<span class="string">&quot;二零二一年&quot;</span>, <span class="number">2</span>, <span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="comment">//这样我们就可以不显式指定D的类型，而默认D类型就是int类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3类模板中成员函数的创建时机"><a href="#2-3类模板中成员函数的创建时机" class="headerlink" title="2.3类模板中成员函数的创建时机"></a>2.3类模板中成员函数的创建时机</h4><p>类模板中成员函数和普通类中成员函数的创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数并不是一开始就创建的，只有在调用时才去创建</li>
</ul>
<h4 id="2-4类模板对象做函数参数"><a href="#2-4类模板对象做函数参数" class="headerlink" title="2.4类模板对象做函数参数"></a>2.4类模板对象做函数参数</h4><ul>
<li>学习使用类模板的实例对象，向函数传参的方式</li>
</ul>
<p>一共有3种传入方式：</p>
<ul>
<li>指定传入的类型：直接显示对象的数据类型（使用最广泛）</li>
<li>参数模板化：将对象中的参数变为模板进行传递</li>
<li>整个类模板化：将对象的类型模板化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T1 r = <span class="number">0.0</span>, T2 i = <span class="number">0.0</span>)</span><br><span class="line">		:<span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T1 <span class="title">get_real</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> real;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T2 <span class="title">get_imag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> imag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show_complex</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;( &quot;</span> &lt;&lt; real &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot; )&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 real;</span><br><span class="line">	T2 imag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1_complex</span><span class="params">(<span class="keyword">const</span> complex&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;&amp; c)</span> </span>&#123;</span><br><span class="line">	c.<span class="built_in">show_complex</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	complex&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;<span class="built_in">c</span>(<span class="number">2.1</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">print1_complex</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2_complex</span><span class="params">(<span class="keyword">const</span> complex&lt;T1, T2&gt;&amp; c)</span> </span>&#123;</span><br><span class="line">	c.<span class="built_in">show_complex</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	complex&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;<span class="built_in">c</span>(<span class="number">-2.1</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">print2_complex</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print3_complex</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span> </span>&#123;</span><br><span class="line">	c.<span class="built_in">show_complex</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	complex&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;<span class="built_in">c</span>(<span class="number">-2.1</span>, <span class="number">-3</span>);</span><br><span class="line">	<span class="built_in">print3_complex</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5类模板与继承"><a href="#2-5类模板与继承" class="headerlink" title="2.5类模板与继承"></a>2.5类模板与继承</h4><p>当类模板碰到继承时，需要注意：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定父类中T的类型，需要将子类也写为类模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">AA</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	T a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> :</span><span class="keyword">public</span> AA&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> :</span><span class="keyword">public</span> AA&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BB b;</span><br><span class="line">	CC&lt;<span class="keyword">double</span>&gt; c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line"><span class="keyword">double</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6类模板成员函数的类外实现"><a href="#2-6类模板成员函数的类外实现" class="headerlink" title="2.6类模板成员函数的类外实现"></a>2.6类模板成员函数的类外实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(T1 r = <span class="number">0</span>, T2 i = <span class="number">0</span>);<span class="comment">//类内声明</span></span><br><span class="line">	<span class="built_in">complex</span>(<span class="keyword">const</span> complex&amp; c)</span><br><span class="line">		:<span class="built_in">real</span>(c.real),<span class="built_in">imag</span>(c.imag) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">complex <span class="title">conj</span><span class="params">()</span></span>;<span class="comment">//类内声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 real;</span><br><span class="line">	T2 imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数类外定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">complex&lt;T1,T2&gt;::<span class="built_in">complex</span>(T1 r ,T2 i)<span class="comment">//（函数默认参数值在声明或定义中只能出现一次）</span></span><br><span class="line">	:<span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数类外定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">complex&lt;T1,T2&gt; complex&lt;T1, T2&gt;::<span class="built_in">conj</span>()&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">complex</span>(real, -imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板成员函数和构造函数在类外实现时，需要对该类的类型加模板参数，比如返回值类型，参数类型，作用域等</p>
<h4 id="2-7类模板分文件编写"><a href="#2-7类模板分文件编写" class="headerlink" title="2.7类模板分文件编写"></a>2.7类模板分文件编写</h4><p>问题：类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</p>
<p>解决：</p>
<ul>
<li>方式1：将原本包含.h文件改为包含.cpp源文件（原因是类模板中成员函数是在当调用这个函数时才被创建，当包含.h文件时，编译器不会到.cpp中去找函数的实现，而当我们改为包含.cpp文件时编译器就会看到这些函数的实现，然后又通过.cpp中的include.h命令看到了.h中的代码）</li>
<li>方式2（常用）：将声明和实现写在同一个文件中，并更改后缀为.hpp，hpp是约定俗成的名称（当使用hpp时通常是在使用类模板的分文件编写），并不是强制的</li>
</ul>
<h4 id="2-8类模板和友元"><a href="#2-8类模板和友元" class="headerlink" title="2.8类模板和友元"></a>2.8类模板和友元</h4><p>掌握类模板配合友元函数的类内和类外实现</p>
<ul>
<li><p>全局函数类内实现（推荐用这个，语法简单）：直接在类内声明友元即可</p>
</li>
<li><p>全局函数类外实现：需要提前让编译器知道全局函数的存在</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span>	<span class="comment">//下面的函数用到person类，提前声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print02_person</span><span class="params">(<span class="keyword">const</span> Person&lt;T1, T2&gt;&amp; p)</span></span>; <span class="comment">//提前声明函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">	<span class="comment">//全局函数类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print01_person</span><span class="params">(<span class="keyword">const</span> Person&lt;T1, T2&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; p.m_name &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.m_age &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">void</span> print02_person&lt;&gt;(<span class="keyword">const</span> Person&lt;T1, T2&gt;&amp; p);<span class="comment">//加&lt;&gt;表明这是个函数模板</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">		:<span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_name;</span><br><span class="line">	T2 m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print02_person</span><span class="params">(<span class="keyword">const</span> Person&lt;T1, T2&gt;&amp; p)</span> </span>&#123;<span class="comment">//函数定义</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; p.m_name &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.m_age &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Lihua&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">	<span class="built_in">print01_person</span>(p);</span><br><span class="line">	<span class="built_in">print02_person</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="STL初识"><a href="#STL初识" class="headerlink" title="STL初识"></a>STL初识</h2><h3 id="1-STL的诞生"><a href="#1-STL的诞生" class="headerlink" title="1.STL的诞生"></a>1.STL的诞生</h3><ul>
<li>长期以来，软件界都希望建立一种可以被重复利用的东西</li>
<li>C++面向对象和泛型编程的思想，目的就是提高代码的复用性</li>
<li>大多数情况下，数据结构和算法未能有一套标准，导致进行了大量的重复工作</li>
<li>为了建立数据结构和算法的一套统一标准，诞生了STL</li>
</ul>
<h3 id="2-STL基本概念"><a href="#2-STL基本概念" class="headerlink" title="2.STL基本概念"></a>2.STL基本概念</h3><ul>
<li>STL（Standard Template Library，标准模板库）</li>
<li>STL在广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）</li>
<li>容器和算法之间通过迭代器连接</li>
<li>sTL几乎所有的代码都在用了类模板或函数模板</li>
</ul>
<h3 id="3-STL六大组件"><a href="#3-STL六大组件" class="headerlink" title="3.STL六大组件"></a>3.STL六大组件</h3><p>STL大体上分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据</li>
<li>算法：各种常用算法，如sort、find、copy、for_each等</li>
<li>迭代器：容器与算法之间的粘合剂</li>
<li>仿函数：行为类似函数，可作为算法的某种策略</li>
<li>适配器（配接器）：一种用于修饰容器、仿函数或者迭代器接口的东西</li>
<li>空间配置器：负责空间的配置和管理</li>
</ol>
<h3 id="4-STL中的容器、算法、迭代器"><a href="#4-STL中的容器、算法、迭代器" class="headerlink" title="4.STL中的容器、算法、迭代器"></a>4.STL中的容器、算法、迭代器</h3><ul>
<li><p>容器：</p>
<p>STL容器就是将运用最广泛的一些数据结构实现出来</p>
<p>常用的数据结构有：数组、链表、树、栈、队列、集合、映射表等</p>
<p>这些容器分为序列式容器和关联式容器两种“</p>
<ul>
<li>序列式容器：容器中每个元素都有固定的位置</li>
<li>关联式容器：元素之间没有严格的物理顺序关系</li>
</ul>
</li>
<li><p>算法：</p>
<p>通过有限的步骤解决逻辑或数学上的问题，我们称之为算法</p>
<p>算法分为：质变算法和非质变算法</p>
<ul>
<li>质变算法：运算过程中会改变区间内元素的内容，例如拷贝，替换，删除等</li>
<li>非质变算法：运算过程中不会改变区间内的元素内容，例如查找、计数、遍历、寻找极值等</li>
</ul>
</li>
<li><p>迭代器：容器和算法之间的粘合剂</p>
<ul>
<li><p>提供一种方法，使其能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式</p>
</li>
<li><p>每个容器都有自己专属的迭代器</p>
</li>
<li><p>算法要通过迭代器才能访问容器中的元素</p>
</li>
<li><p>迭代器的使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
</li>
<li><p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、!=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写操作</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、!=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器为双向迭代器和随机访问迭代器</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-容器算法迭代器初识"><a href="#5-容器算法迭代器初识" class="headerlink" title="5.容器算法迭代器初识"></a>5.容器算法迭代器初识</h3><h4 id="5-1vector存放内置数据类型"><a href="#5-1vector存放内置数据类型" class="headerlink" title="5.1vector存放内置数据类型"></a>5.1vector存放内置数据类型</h4><ul>
<li>容器：vector</li>
<li>算法：for_each</li>
<li>迭代器：vector&lt;int&gt;::iterator</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_T</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建存放内置数据类型int的容器v</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">	<span class="comment">//向容器中添加数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it_begin = v.<span class="built_in">begin</span>();<span class="comment">//起始迭代器 指向容器v的第一个元素</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::iterator it_end = v.<span class="built_in">end</span>();	<span class="comment">//尾后迭代器 指向最后一个元素的后一个位置</span></span><br><span class="line">	<span class="comment">//遍历方式1</span></span><br><span class="line">	<span class="keyword">while</span> (it_begin != it_end) &#123;</span><br><span class="line">		cout &lt;&lt; *it_begin &lt;&lt; endl;</span><br><span class="line">		it_begin++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历方式2</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历方式3(利用STL中的算法for_each)</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print_T&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2vector存放自定义数据类型"><a href="#5-2vector存放自定义数据类型" class="headerlink" title="5.2vector存放自定义数据类型"></a>5.2vector存放自定义数据类型</h4><p>complex.h文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">complex</span>(<span class="keyword">int</span> real = <span class="number">0</span>, <span class="keyword">int</span> imag = <span class="number">0</span>)</span><br><span class="line">		:<span class="built_in">m_real</span>(real), <span class="built_in">m_imag</span>(imag) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_real;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_imag;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_real;</span><br><span class="line">	<span class="keyword">int</span> m_imag;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> complex&amp; c) &#123;</span><br><span class="line">	os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.<span class="built_in">get_real</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; c.<span class="built_in">get_imag</span>() &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;complex.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_T</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建存放内置数据类型int的容器v</span></span><br><span class="line">	vector&lt;complex&gt; v;</span><br><span class="line">	<span class="comment">//向容器中添加数据</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(<span class="built_in">complex</span>(i*i,i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过迭代器访问容器中的数据</span></span><br><span class="line">	vector&lt;complex&gt;::iterator it_begin = v.<span class="built_in">begin</span>();<span class="comment">//起始迭代器 指向容器v的第一个元素</span></span><br><span class="line">	vector&lt;complex&gt;::iterator it_end = v.<span class="built_in">end</span>();	<span class="comment">//尾后迭代器 指向最后一个元素的后一个位置</span></span><br><span class="line">	<span class="comment">//遍历方式1</span></span><br><span class="line">	<span class="keyword">while</span> (it_begin != it_end) &#123;</span><br><span class="line">		cout &lt;&lt; *it_begin &lt;&lt; endl;</span><br><span class="line">		it_begin++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历方式2</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;complex&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历方式3(利用STL中的算法for_each)</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print_T&lt;complex&gt;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3容器嵌套容器"><a href="#5-3容器嵌套容器" class="headerlink" title="5.3容器嵌套容器"></a>5.3容器嵌套容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;complex.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">	<span class="comment">//添加元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; vj;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">			vj.<span class="built_in">push_back</span>((i+<span class="number">1</span>)*(j+<span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		v.<span class="built_in">push_back</span>(vj);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">for</span> (vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator it_i = v.<span class="built_in">begin</span>(); it_i != v.<span class="built_in">end</span>(); it_i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it_j = (*it_i).<span class="built_in">begin</span>(); it_j != (*it_i).<span class="built_in">end</span>(); it_j++) &#123;</span><br><span class="line">			cout &lt;&lt; *it_j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yangjiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yyangjiao.github.io/2021/10/21/cpp-note/">https://yyangjiao.github.io/2021/10/21/cpp-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yyangjiao.github.io" target="_blank">yangjiao's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/yyangjiao/illustration_host/raw/master/img7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/10/20/nginx%E9%83%A8%E7%BD%B2hexo/"><img class="next-cover" src="https://gitee.com/yyangjiao/illustration_host/raw/master/img6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">nginx部署hexo</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yangjiao</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yyangjiao"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C++基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.1.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E9%92%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.指针数据类型所占的内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.空指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.野指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.const修饰指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.指针和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.指针和函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.结构体定义和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.结构体数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.结构体指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.结构体嵌套结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.结构体作函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%ADconst%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.结构体中const的使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%B8%E5%BF%83"><span class="toc-number">2.</span> <span class="toc-text">C++核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">内存分区模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%92%8C%E5%85%A8%E5%B1%80%E5%8C%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.代码区和全局区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-new%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.new操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.引用的基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.引用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%95%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.引用作函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%95%E7%94%A8%E4%BD%9C%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.2.4.</span> <span class="toc-text">4.引用作函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.2.5.</span> <span class="toc-text">5.引用的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.6.</span> <span class="toc-text">6.常量引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98"><span class="toc-number">2.3.</span> <span class="toc-text">函数提高</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.函数默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.函数占位参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B0%81%E8%A3%85"><span class="toc-number">2.4.1.</span> <span class="toc-text">1.封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.对象的初始化和清理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">2.1构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">2.2拷贝构造函数的调用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">2.3构造函数调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">2.4深拷贝与浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">2.5初始化列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.2.6.</span> <span class="toc-text">2.6类对象作为类的成员属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">2.4.2.7.</span> <span class="toc-text">2.7静态成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.C++对象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-this%E6%8C%87%E9%92%88"><span class="toc-number">2.4.4.</span> <span class="toc-text">4.this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1this%E6%8C%87%E9%92%88%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">4.1this指针概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">4.2空指针访问成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">4.3const修饰成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8B%E5%85%83"><span class="toc-number">2.4.5.</span> <span class="toc-text">5.友元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">5.1全局函数作友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2%E5%85%B6%E4%BB%96%E7%B1%BB%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">5.2其他类作友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E5%8F%8B%E5%85%83"><span class="toc-number">2.4.5.3.</span> <span class="toc-text">5.3成员函数作友元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.6.</span> <span class="toc-text">6.运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">6.1加号运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E2%80%9D-lt-lt-%E2%80%9D%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">6.2左移运算符”&lt;&lt;”重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.6.3.</span> <span class="toc-text">6.3自增运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.6.4.</span> <span class="toc-text">6.4赋值运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.6.5.</span> <span class="toc-text">6.5关系运算符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.4.6.6.</span> <span class="toc-text">6.6函数调用运算符重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.7.</span> <span class="toc-text">7.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">7.1继承的基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">7.2继承方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">7.3继承中的对象模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">7.4继承中构造和析构的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.7.5.</span> <span class="toc-text">7.5继承中同名成员的处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.7.6.</span> <span class="toc-text">7.6继承中同名静态成员的处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.7.7.</span> <span class="toc-text">7.7多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.7.8.</span> <span class="toc-text">7.8虚继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A4%9A%E6%80%81"><span class="toc-number">2.4.8.</span> <span class="toc-text">8.多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.8.1.</span> <span class="toc-text">8.1多态的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">2.4.8.2.</span> <span class="toc-text">8.2多态的原理剖析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.4.8.3.</span> <span class="toc-text">8.3纯虚函数和抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-number">2.4.8.4.</span> <span class="toc-text">8.4虚析构和纯虚析构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.1.</span> <span class="toc-text">1.写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.读文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.3.</span> <span class="toc-text">3.二进制方式写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.4.</span> <span class="toc-text">4.二进制方式读文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%8F%90%E9%AB%98"><span class="toc-number">3.</span> <span class="toc-text">C++提高</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.1.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">1.1函数模板的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">1.2函数模板与普通函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">1.3函数模板与普通函数调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">1.4模板的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">2.1类模板的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">2.2类模板与函数模板的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">2.3类模板中成员函数的创建时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">2.4类模板对象做函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">2.5类模板与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">2.6类模板成员函数的类外实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-number">3.1.2.7.</span> <span class="toc-text">2.7类模板分文件编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%8F%8B%E5%85%83"><span class="toc-number">3.1.2.8.</span> <span class="toc-text">2.8类模板和友元</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%88%9D%E8%AF%86"><span class="toc-number">3.2.</span> <span class="toc-text">STL初识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-STL%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.STL的诞生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.STL基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.STL六大组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-STL%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">4.STL中的容器、算法、迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E8%AF%86"><span class="toc-number">3.2.5.</span> <span class="toc-text">5.容器算法迭代器初识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1vector%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">5.1vector存放内置数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2vector%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">5.2vector存放自定义数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E5%AE%B9%E5%99%A8%E5%B5%8C%E5%A5%97%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">5.3容器嵌套容器</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/21/cpp-note/" title="cpp-note"><img src="https://gitee.com/yyangjiao/illustration_host/raw/master/img7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cpp-note"/></a><div class="content"><a class="title" href="/2021/10/21/cpp-note/" title="cpp-note">cpp-note</a><time datetime="2021-10-21T08:50:24.000Z" title="发表于 2021-10-21 16:50:24">2021-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/20/nginx%E9%83%A8%E7%BD%B2hexo/" title="nginx部署hexo"><img src="https://gitee.com/yyangjiao/illustration_host/raw/master/img6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nginx部署hexo"/></a><div class="content"><a class="title" href="/2021/10/20/nginx%E9%83%A8%E7%BD%B2hexo/" title="nginx部署hexo">nginx部署hexo</a><time datetime="2021-10-20T08:09:42.000Z" title="发表于 2021-10-20 16:09:42">2021-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/19/Ubuntu18.04%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/" title="Ubuntu18.04设置开机自启动脚本"><img src="https://gitee.com/yyangjiao/illustration_host/raw/master/img5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ubuntu18.04设置开机自启动脚本"/></a><div class="content"><a class="title" href="/2021/10/19/Ubuntu18.04%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/" title="Ubuntu18.04设置开机自启动脚本">Ubuntu18.04设置开机自启动脚本</a><time datetime="2021-10-19T13:20:21.000Z" title="发表于 2021-10-19 21:20:21">2021-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/07/hexo-note/" title="hexo-note"><img src="https://gitee.com/yyangjiao/illustration_host/raw/master/img4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo-note"/></a><div class="content"><a class="title" href="/2021/10/07/hexo-note/" title="hexo-note">hexo-note</a><time datetime="2021-10-06T16:10:47.000Z" title="发表于 2021-10-07 00:10:47">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/nvm-note/" title="nvm-note"><img src="https://gitee.com/yyangjiao/illustration_host/raw/master/img3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nvm-note"/></a><div class="content"><a class="title" href="/2021/10/06/nvm-note/" title="nvm-note">nvm-note</a><time datetime="2021-10-06T05:09:40.000Z" title="发表于 2021-10-06 13:09:40">2021-10-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By yangjiao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>